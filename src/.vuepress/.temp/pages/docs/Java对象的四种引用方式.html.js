export const data = JSON.parse("{\"key\":\"v-3a80a4d0\",\"path\":\"/docs/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F.html\",\"title\":\"Java对象的四种引用方式\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"Java对象的四种引用方式\",\"date\":\"2021-12-07T01:42:49.000Z\",\"categories\":\"JVM\",\"tags\":[\"Java\",\"JVM\"],\"description\":\"Reference public abstract class Reference&lt;T&gt; { //引用的对象 private T referent; //回收队列，由使用者在Reference的构造函数中指定 volatile ReferenceQueue&lt;? super T&gt; queue; //当该引用被加入到queue中的时候，该字段被设置为queue中的下一个元素，以形成链表结构 volatile Reference next; //在GC时，JVM底层会维护一个叫DiscoveredList的链表，存放的是Reference对象，discovered字段指向的就是链表中的下一个元素，由JVM设置 transient private Reference&lt;T&gt; discovered; //进行线程同步的锁对象 static private class Lock { } private static Lock lock = new Lock(); //等待加入queue的Reference对象，在GC时由JVM设置，会有一个java层的线程(ReferenceHandler)源源不断的从pending中提取元素加入到queue private static Reference&lt;Object&gt; pending = null; }\"},\"headers\":[],\"readingTime\":{\"minutes\":3.73,\"words\":1120},\"filePathRelative\":\"docs/Java对象的四种引用方式.md\",\"localizedDate\":\"2021年12月7日\",\"excerpt\":\"<h1> Reference</h1>\\n<div class=\\\"language-java line-numbers-mode\\\" data-ext=\\\"java\\\"><pre class=\\\"language-java\\\"><code><span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">abstract</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Reference</span><span class=\\\"token generics\\\"><span class=\\\"token punctuation\\\">&lt;</span><span class=\\\"token class-name\\\">T</span><span class=\\\"token punctuation\\\">&gt;</span></span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token comment\\\">//引用的对象</span>\\n    <span class=\\\"token keyword\\\">private</span> <span class=\\\"token class-name\\\">T</span> referent<span class=\\\"token punctuation\\\">;</span>        \\n    <span class=\\\"token comment\\\">//回收队列，由使用者在Reference的构造函数中指定</span>\\n    <span class=\\\"token keyword\\\">volatile</span> <span class=\\\"token class-name\\\">ReferenceQueue</span><span class=\\\"token generics\\\"><span class=\\\"token punctuation\\\">&lt;</span><span class=\\\"token operator\\\">?</span> <span class=\\\"token keyword\\\">super</span> <span class=\\\"token class-name\\\">T</span><span class=\\\"token punctuation\\\">&gt;</span></span> queue<span class=\\\"token punctuation\\\">;</span>\\n     <span class=\\\"token comment\\\">//当该引用被加入到queue中的时候，该字段被设置为queue中的下一个元素，以形成链表结构</span>\\n    <span class=\\\"token keyword\\\">volatile</span> <span class=\\\"token class-name\\\">Reference</span> next<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token comment\\\">//在GC时，JVM底层会维护一个叫DiscoveredList的链表，存放的是Reference对象，discovered字段指向的就是链表中的下一个元素，由JVM设置</span>\\n    <span class=\\\"token keyword\\\">transient</span> <span class=\\\"token keyword\\\">private</span> <span class=\\\"token class-name\\\">Reference</span><span class=\\\"token generics\\\"><span class=\\\"token punctuation\\\">&lt;</span><span class=\\\"token class-name\\\">T</span><span class=\\\"token punctuation\\\">&gt;</span></span> discovered<span class=\\\"token punctuation\\\">;</span>  \\n    <span class=\\\"token comment\\\">//进行线程同步的锁对象</span>\\n    <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Lock</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token class-name\\\">Lock</span> lock <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Lock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token comment\\\">//等待加入queue的Reference对象，在GC时由JVM设置，会有一个java层的线程(ReferenceHandler)源源不断的从pending中提取元素加入到queue</span>\\n    <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token class-name\\\">Reference</span><span class=\\\"token generics\\\"><span class=\\\"token punctuation\\\">&lt;</span><span class=\\\"token class-name\\\">Object</span><span class=\\\"token punctuation\\\">&gt;</span></span> pending <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">null</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre><div class=\\\"line-numbers\\\" aria-hidden=\\\"true\\\"><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div></div></div>\",\"autoDesc\":true}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
