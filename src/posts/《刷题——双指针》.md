---
title: 《刷题——双指针》
date: 2023-01-09 15:39:35
categories: 算法题
tags:
---





## 双指针



### 两数之和

```java
import java.util.*;


public class Solution {
    /**
     * @param numbers int整型一维数组
     * @param target  int整型
     * @return int整型一维数组
     */
    public int[] twoSum(int[] numbers, int target) {
        // write code here
        int n = numbers.length;
        int[][] a = new int[n][2];
        for (int i = 0; i < numbers.length; i++) {
            a[i] = new int[]{numbers[i], i};
        }
        Arrays.sort(a, Comparator.comparingInt(o -> o[0]));
        int i = 0, j = n - 1;
        int[] ans = {0, 0};
        while (i < j) {
            int sum = a[i][0] + a[j][0];
            if (sum == target) {
                ans[0] = a[i][1] + 1;
                ans[1] = a[j][1] + 1;
                if (ans[0] > ans[1]) {
                    int t = ans[0];
                    ans[0] = ans[1];
                    ans[1] = t;
                }
                break;
            } else if (sum < target) {
                i++;
            } else {
                j--;
            }
        }
        return ans;
    }
}
```




### 三数之和

```java
import java.util.*;

public class Solution {
    public ArrayList<ArrayList<Integer>> threeSum(int[] num) {
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        Arrays.sort(num);
        int n = num.length;
        for(int i = 0; i < n - 2; i++) {
            if(i > 0 && num[i] == num[i-1]) continue; // 去重
            int j = i + 1;
            int k = n - 1;
            int target = -num[i];
            while(j < k) {
                if(j > i+1 && num[j] == num[j-1]) { // 去重复
                    j++;
                    continue;
                }
                if(k < n-1 && num[k] == num[k+1]) { // 去重
                    k--;
                    continue;
                }
                int sum = num[j] + num[k];
                // 两数之和的逻辑
                if(sum == target) {
                    ans.add(new ArrayList<>(Arrays.asList(num[i], num[j], num[k])));
                    // 可能还有
                    j++;
                    k--;
                } else if(sum < target) {
                    j++;
                } else {
                    k--;
                }
            }
        }
        return ans;
    }
}
```



### 接雨水

https://song-yang-ji.blog.csdn.net/article/details/114880206

```java
import java.util.*;

public class Solution {
    /**
     * max water
     * @param arr int整型一维数组 the array
     * @return long长整型
     */
    public long maxWater (int[] arr) {
        // write code here
        long ans = 0;
        int n = arr.length;
        if(n <= 2) return ans;
        int l = 1, r = n - 2;
        int lm = arr[0], rm = arr[n-1];  // 维护左端和右端的已经出现过的最大值
        while(l <= r) { // 注意是 <= 
            if(lm <= rm) {
                ans += Math.max(0, lm - arr[l]);
                lm = Math.max(lm, arr[l++]);
            } else {
                ans += Math.max(0, rm - arr[r]);
                rm = Math.max(rm , arr[r--]);
            }
        }
        return ans;
    }
}
```



## 滑动窗口



### 雪花串

```java
import java.util.*;

public class Solution {
    /**
     * 
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int maxLength (int[] arr) {
        // write code here
        HashSet<Integer> set = new HashSet<>();
        int l = 0, r = 0 , n = arr.length;
        int ans = 0;
        for(; r < n; r++) {
            while(set.contains(arr[r])) { // l < r
                set.remove(arr[l++]);
            }
            set.add(arr[r]);
            ans = Math.max(ans, r - l + 1);
        }
        return ans;
    }
}
```



### 最小覆盖子串（滑动窗口）
给出两个字符串 s 和 t，要求在 s 中找出最短的包含 t 中所有字符的连续子串。
数据范围：0 > |S|,|T| $\le$100000>∣*S*∣,∣*T*∣ $\le$ 10000，保证s和t字符串中仅包含大小写英文字母
要求：进阶：空间复杂度 O(n) ， 时间复杂度 O(n)

例如：
S ="XDOYEZODEYXNZ"
T ="XYZ"
找出的最短子串为"YXNZ"

注意：
如果 s 中没有包含 t 中所有字符的子串，返回空字符串 “”；
满足条件的子串可能有很多，但是题目保证满足条件的最短的子串唯一。

```java
import java.util.*;

public class Solution {

    int[] cur = new int[100];
    int[] cnt = new int[100];

    public String minWindow(String ss, String t) {
        if (t.length() == 0) return "";
        char[] s = ss.toCharArray();
        int len = s.length;
        for (int i = 0; i < t.length(); i++) {
            cnt[t.charAt(i) - 'A']++;
        }
        int i = 0, j = 0;
        String ans = "";
        int minLen = len + 10;
        // 特点，串越长越好（注意“雪花串“中，串越小越好）
        while (i < len) {
            while (j < len && !ok()) { // 不ok，一直移动右窗口
                ++cur[s[j++] - 'A'];
            }
            if (!ok()) break;
            
            while (i < j && ok()) {    // ok后，一直移动左窗口
                --cur[s[i++] - 'A'];
            }
            if(minLen > (j - (i - 1))) { // [i - 1, j)
                minLen = j - (i - 1);
                ans = ss.substring(i - 1, j);
            }
        }
        return minLen > len ? "" : ans;
    }
    
    boolean ok() {
        for (int i = 0; i < 100; i++) {
            if (cur[i] < cnt[i]) return false;
        }
        return true;
    }

}
```