---
title: 《刷题——动态规划》
date: 2023-01-01 02:51:04
categories: 算法题
tags:
---



## DP

### 最长公共子串

```java
import java.util.*;

public class Solution {
    /**
     * longest common substring
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @return string字符串
     */
    int N = 5010;
    public String LCS (String str1, String str2) {
        // write code here
        int[][] f = new int[N][N]; // 
        String ans = null;
        char[] s1 = str1.toCharArray();
        char[] s2 = str2.toCharArray();
        int maxLen = 0;
        int l1 = 0, l2 = 0, n1 = s1.length, n2 = s2.length;
        for(int i = 1; i <= n1; i++) {
            for(int j = 1; j <= n2; j++) {
                if(s1[i - 1] == s2[j - 1]) {
                    f[i][j] = f[i-1][j-1] + 1;
                    
                    if(f[i][j] > maxLen) {
                        maxLen = f[i][j];
                        l1 = i - maxLen; 
                    }
                } else {
                    f[i][j] = 0; // 子串其实更简单
                }
                /*
                if(text1[i] == text2[j]) {
                    a[i][j] = a[i-1][j-1] + 1;
                } else {
                    a[i][j] = max(a[i-1][j], a[i][j-1]);
                }
                */
            }
        }

        ans = str1.substring(l1, l1 + maxLen);
        return ans;
    }
}
```


### LCS（最长公共子序列）
key：**如何反推结果**

```java
import java.util.*;


public class Solution {
    /**
     * longest common subsequence
     *
     * @param s1 string字符串 the string
     * @param s2 string字符串 the string
     * @return string字符串
     */
    public String LCS(String s1, String s2) {
        // write code here
        int str1Len = s1.length();
        int str2Len = s2.length();
        int[][] cLenNUm = new int[s1.length() + 1][s2.length() + 1];//默认赋值，[0][?],[?][0]默认两侧皆0,类似公式中0的场景
        //构造一个LCS长度数组
        for (int i = 1; i <= str1Len; i++) {
            for (int j = 1; j <= str2Len; j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {//对应公式第二条相等
                    cLenNUm[i][j] = cLenNUm[i - 1][j - 1] + 1;
                } else {//对应公式第三条不相等
                    cLenNUm[i][j] = Math.max(cLenNUm[i][j - 1], cLenNUm[i - 1][j]);
                }
            }
        }

        //反推结果
        int i = str1Len;
        int j = str2Len;
        StringBuilder sb = new StringBuilder();//作为结果
        while (i > 0 && j > 0) {
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {//反推公式相等的场景
                //该值一定是被选取到的，根据之前的公式，知道两条字符串的下标都前进一位
                sb.append(s1.charAt(i - 1));
                i--;
                j--;
            } else { // 上面的max中，哪个大，说明从哪个转移而来，现在就倒推回去
                if (cLenNUm[i][j - 1] >= cLenNUm[i - 1][j]) {
                    j--;
                } else {
                    i--;
                }
            }
        }
        //由于是从后往前加入字符的，需要反转才能得到正确结果
        if (sb.length() == 0) return "-1";
        return sb.reverse().toString();
    }
}
```



### 编辑距离（LCS变种）

```java
import java.util.*;

public class Solution {
    /**
     * min edit cost
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @param ic int整型 insert cost
     * @param dc int整型 delete cost
     * @param rc int整型 replace cost
     * @return int整型
     */
    // 从 str1 转换到 str2的开销
    public int minEditCost (String str1, String str2, int ic, int dc, int rc) {
        // write code here
        int m = str1.length();
        int n = str2.length();
        int[][] f = new int[m + 10][n + 10];
        str1 = " " + str1; 
        str2 = " " + str2;
        f[0][0] = 0;
        for(int i = 1; i <= m; i++) {
            f[i][0] = i * dc;
        }
        for(int j = 1; j <= n; j++) {
            f[0][j] = j * ic;
        }
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                int cost = (int)1e8;
                cost = Math.min(cost, f[i - 1][j] + dc); // 不要搞反
                cost = Math.min(cost, f[i][j - 1] + ic);
                cost = Math.min(cost, f[i - 1][j - 1] + rc * (str1.charAt(i) == str2.charAt(j) ? 0 : 1));
                f[i][j] = cost;
            }
        }
        return f[m][n];
    }
}
```





### 扔鸡蛋

时间复杂度：O(nk)=O(nlogn)


```cpp
#define inf 0x3f3f3f3f

class Solution {
public:
    /*
    状态：f[i][j] i个棋子，j层楼的操作系数
    转移：f[i][j] = 1 + max(f[i - 1][t - 1], f[i][j - t]) 枚举所有的t，找出最优的
    初始：f[1][j] = j;

    空间优化，i的维度只用到当前状态和前一个状态，所有可以使用滚动数组优化成f[j]
    时间优化，i确定的时候，f[i - 1][t - 1]随t单调增，f[i][j - t]随t单调减，临界点的寻找可以用单调性优化
    */

    const int N = 1000010;

    int solve(int n, int k) {
        // 优化性质, 如果k充分大, 二分的扔即可（有点投机取巧）
        int b = log2(n) + 1;
        if(k >= log2(n) + 1) {
            return b;
        }
        k = min(k, n);
        // write code here
        vector<int> f0(N), f1(N);

        // 初始化
        for (int j = 0; j <= n; ++j) {
            f0[j] = j;
        }

        for (int i = 2; i <= k; ++i) {
            int tt = 1; // 临界点逐渐递增
            for(int j = 1; j <= n; j++) {
                int res = inf;
//                原始版本                
//                for(int t = j; t >= tt; --t) {
//                    res = min(res, max(f0[t - 1], f1[j - t]) + 1);
//                }
                while (tt <= j && f0[tt - 1] < f1[j - tt]) {
                    ++tt;
                }
                res = f1[j - (tt - 1)];
                if(tt <= j) res = min(res, f0[tt - 1]);
                f1[j] = res + 1;
            }
            f0 = f1;
        }
        return f0[n];
    }
};

```


> 题解
>
> https://song-yang-ji.blog.csdn.net/article/details/121206001
>
> https://blog.nowcoder.net/n/702aa052fefb4b7d8e2949874c52316a?f=comment





### NC122 正则表达式匹配

https://www.nowcoder.com/practice/28970c15befb4ff3a264189087b99ad4?tpId=117&tqId=37780&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fdifficulty%3D4%26judgeStatus%3D3%26page%3D1%26pageSize%3D50%26search%3D%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=4&judgeStatus=3&tags=&title=

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param str string字符串
     * @param pattern string字符串
     * @return bool布尔型
     */

    bool match(string s, string p) {
        if (p[0] == '*') { // assert
            return false;
        }
        int m = s.length();
        int n = p.length();
        s = " " + s;
        p = " " + p;
        vector<vector<bool> > f(m + 10, vector<bool>(n + 10));
        f[0][0] = true;
        // key: i start from 0
        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p[j] == '*') { // assert j >= 2
                    char c = p[j - 1];
                    if (f[i][j - 2]) { // 一次不用
                        f[i][j] = true;
                    } else {
                        int k = 0;
                        while (i > k && (c == '.' || s[i - k] == c)) {
                            if (f[i - k - 1][j - 2]) {
                                f[i][j] = true;
                                break;
                            }
                            ++k;
                        }
                    }
                } else {
                    if (i > 0 && f[i - 1][j - 1] && (s[i] == p[j] || p[j] == '.')) {
                        f[i][j] = true;
                    }
                }
            }
        }
        return f[m][n];
    }
};
```





更优秀的写法：

```cpp
class Solution {
public:
    bool f[30][40] = {0};
    bool isMatch(string s, string p) {
        int m = s.size(), n = p.size();
        s = " " + s;
        p = " " + p;
        f[0][0] = 1;

        auto ok = [&](int i, int j) {
            if(i == 0 || j == 0) return false;
            return p[j] == '.' || s[i] == p[j];
        };

        for(int i = 0; i <= m; i++) { // from 0
            for(int j = 1; j <= n; j++) { // from 1
                if(p[j] == '*') {
                    f[i][j] = f[i][j - 2]; // 题给数据保证不越界
                    if(ok(i, j - 1)) {
                        f[i][j] |= f[i - 1][j]; // key
                    }
                } else {
                    f[i][j] = ok(i, j) ? f[i - 1][j - 1] : false;
                }
            }
        }
        return f[m][n];
    }
};

```





> 题解
>
> https://song-yang-ji.blog.csdn.net/article/details/121688339





### NC44通配符匹配

时间复杂度：O(m*n)

```cpp
class Solution {
public:
    bool isMatch(const char *ps, const char *pp) {
        int m = strlen(ps);
        int n = strlen(pp);
        string s = " " + string(ps);
        string p = " " + string(pp);
        vector<vector<bool>> f(m + 10, vector<bool>(n + 10));
        f[0][0] = 1;
        for (int i = 0; i <= m; ++i) { // from 0
            for (int j = 1; j <= n; ++j) { // from 1
                if (p[j] == '*') {
                    f[i][j] = f[i][j - 1] || (i > 0 && f[i - 1][j]);
                } else {
                    if (i > 0 && (s[i] == p[j] || p[j] == '?')) {
                        f[i][j] = f[i - 1][j - 1];
                    }
                }
            }
        }
        return f[m][n];
    }
};
```



todo:

空间复杂度 O(1)，时间复杂度 O(n)

```cpp

```



### **NC134** **买卖股票的最好时机(二)**

https://www.nowcoder.com/practice/9e5e3c2603064829b0a0bbfca10594e9?tpId=117&tqId=37846&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fdifficulty%3D3%26judgeStatus%3D3%26page%3D1%26pageSize%3D50%26search%3D%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=3&judgeStatus=3&tags=&title=



```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算最大收益
     * @param prices int整型vector 股票每一天的价格
     * @return int整型
     */
    int maxProfit(vector<int>& a) {
        // write code here
        int n = a.size();
        vector<vector<int>> f(n + 10, vector<int>(2));
        f[0][0] = 0;
        f[0][1] = - a[0];
        for(int i = 1; i < n; ++i) {
            f[i][0] = max(f[i - 1][1] + a[i], f[i - 1][0]);
            f[i][1] = max(f[i - 1][0] - a[i], f[i - 1][1]);
        }
        return f[n - 1][0];
    }
};
```





### NC135 买卖股票的最好时机(三)

https://www.nowcoder.com/practice/4892d3ff304a4880b7a89ba01f48daf9?tpId=117&tqId=37847&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fdifficulty%3D4%26judgeStatus%3D3%26page%3D1%26pageSize%3D100%26search%3D%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=4&judgeStatus=3&tags=&title=

```cpp
const int N = 100010;
const int inf = 0x3f3f3f3f;
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 两次交易所能获得的最大收益
     * @param prices int整型vector 股票每一天的价格
     * @return int整型
     */
    
    int maxProfit(vector<int>& a) {
        // write code here
        int n = a.size();
        int f[N][3][2] = {0};
        // 初始化
        f[0][0][1] = -a[0];
        f[0][1][0] = -inf;
        f[0][1][1] = -inf;
        f[0][2][0] = -inf;
        for(int i = 1; i < n; ++i) {
            f[i][0][1] = max(f[i - 1][0][1], f[i - 1][0][0] - a[i]);
            f[i][1][0] = max(f[i - 1][1][0], f[i - 1][0][1] + a[i]);
            f[i][1][1] = max(f[i - 1][1][1], f[i - 1][1][0] - a[i]);
            f[i][2][0] = max(f[i - 1][2][0], f[i - 1][1][1] + a[i]);
        }
        
        int ans = 0;
        for(int i = 0; i < 3; ++i) {
            for(int j = 0; j < 2; ++j) {
                ans = max(ans, f[n - 1][i][j]);
            }
        }
        return ans;
    }
};
```



### **NC167** **买卖股票的最好时机(四)**

https://www.nowcoder.com/practice/1c583d416d504b80821fbe4cc20404f3?tpId=117&tqId=39309&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fdifficulty%3D4%26judgeStatus%3D3%26page%3D1%26pageSize%3D100%26search%3D%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=4&judgeStatus=3&tags=&title=

```cpp
#define inf 0x3f3f3f3f
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param prices int整型vector
     * @param k int整型
     * @return int整型
     */
    int maxProfit(vector<int> &a, int K) {
        // write code here
        int n = a.size();
        vector<vector<vector<int>>> f(n + 10, vector<vector<int>>(K + 1, vector<int>(2, -inf)));
        // init
        f[0][0][0] = 0;
        f[0][0][1] = -a[0];
        for (int i = 1; i < n; ++i) {
            for (int k = 0; k <= K; ++k) {
                f[i][k][0] = max(f[i - 1][k][0], k > 0 ? (f[i - 1][k - 1][1] + a[i]) : -inf);
                f[i][k][1] = max(f[i - 1][k][1], f[i - 1][k][0] - a[i]);
            }
        }
        int ans = 0;
        for (int i = 0; i <= K; i++) {
            for (int j = 0; j < 2; j++) {
                ans = max(ans, f[n - 1][i][j]);
            }
        }
        return ans;
    }
};
```





### **NC173** **填充数组**

https://www.nowcoder.com/practice/3e34d9ed0bbc4db68b6fbca20a62926d?tpId=117&tqId=39329&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fdifficulty%3D4%26judgeStatus%3D3%26page%3D1%26pageSize%3D100%26search%3D%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=4&judgeStatus=3&tags=&title=

**计数DP**

加法原理

```cpp
const int MOD = 1e9 + 7; 
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param a int整型vector 
     * @param k int整型 
     * @return int整型
     */
    int FillArray(vector<int>& a, int K) {
        // write code here
        int n = a.size();
        vector<vector<int>> f(n + 10, vector<int>(K + 10));
        // init
        if(a[0]) {
            f[0][a[0]] = 1;
        } else {
            for(int k = 1; k <= K; ++k) {
                f[0][k] = 1;
            }
        }
        for(int i = 1; i < n; ++i) {
            int tmp = 0;
            if(a[i]) {
                for(int k = 1; k <= a[i]; ++k) {
                    tmp = (tmp + f[i - 1][k]) % MOD;
                }
                f[i][a[i]] = tmp;
            } else {
                for(int k = 1; k <= K; ++k) {
                    tmp = (tmp + f[i - 1][k]) % MOD;
                    f[i][k] = tmp;
                }
            }
        }
        int ans = 0;
        for(int k = 1; k <= K; ++k) {
            ans = (ans + f[n - 1][k]) % MOD;
        }
        return ans;
    }
};
```



### **NC178** **打家劫舍(三)**

https://www.nowcoder.com/practice/82b6dce6a7634419b272ee4397e26d89?tpId=117&tqId=39334&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fdifficulty%3D4%26judgeStatus%3D3%26page%3D1%26pageSize%3D100%26search%3D%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=4&judgeStatus=3&tags=&title=

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param root TreeNode类
     * @return int整型
     */
    unordered_map<TreeNode *, unordered_map<bool, int>> dp;

    int rob(TreeNode *root) {
        // write code here
        return max(help(root->left, false) + help(root->right, false),
                   root->val + help(root->left, true) + help(root->right, true));
    }

    int help(TreeNode *root, bool pick) {
        if (root == nullptr) return 0;
        if(dp[root][pick]) return dp[root][pick];
        int res = help(root->left, false) + help(root->right, false);
        if (!pick) {
            res = max(res, root->val + help(root->left, true) + help(root->right, true));
        }
        dp[root][pick] = res;
        return res;
    }
};
```



或者更好的：

```cpp
class Solution {
public:
    unordered_map<TreeNode *, int> mp1, mp2;//mp1,mp2分别表示当前节点偷或不偷的最大金额

    int rob(TreeNode *root) {
        f(root);//递归
        return max(mp1[root], mp2[root]);//返回最大值
    }

    void f(TreeNode *root) {//递归
        if (root == nullptr)
            return;
        f(root->left);//左递归
        f(root->right);//右递归
        mp1[root] = root->val + mp2[root->left] + mp2[root->right];//当前节点偷
        mp2[root] = max(mp1[root->left], mp2[root->left]) + max(mp1[root->right], mp2[root->right]);//当前节点不偷
    }
};
```



### **NC187** **压缩字符串(二)**

https://www.nowcoder.com/practice/2724df81a7d94b70932d96b759848f0a?tpId=117&tqId=39354&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fdifficulty%3D4%26judgeStatus%3D3%26page%3D1%26pageSize%3D100%26search%3D%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=4&judgeStatus=3&tags=&title=

```cpp
#define inf 0x3f3f3f3f
#define ll long long
#define ull unsigned long long

class Solution {
public:
    int f[110][110];
    int n;
    string s;

    int compressString(string s, int k) {
        // write code here
        n = s.length();
        this->s = s;
        if (n == 0) return 0;
        memset(f, inf, sizeof f);
        return dfs(0, k);
    }

    int trans(int num) {
        if (num == 1) return 1;
        string numStr = to_string(num);
        return numStr.length() + 1;
    }

    int dfs(int idx, int k) {
        if (idx == n) return 0;
        int &res = f[idx][k];
        if (res != inf) return res;
        if (k) res = dfs(idx + 1, k - 1); // 删除 s[idx]
        char c = s[idx];
        int same = 0, diff = 0; // key
        for (int i = idx; i < n; ++i) {
            if (c == s[i]) {
                ++same;
                res = min(res, trans(same) + dfs(i + 1, k - diff));
            } else {
                res = min(res, trans(same) + dfs(i, k - diff));
                ++diff;
                if (diff > k) break;
            }
        }
        return res;
    }
};
```



```cpp
#define inf 0x3f3f3f3f
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param s string字符串 
     * @param k int整型 
     * @return int整型
     */
    int f[110][110];
    int compressString(string s, int K) {
        // write code here
        int n = s.size();
        memset(f, inf, sizeof(f));
        s = " " + s;
        for(int k = 0; k <= K; ++k) f[0][k] = 0;
        for(int i = 1; i <= n; ++i) {
            for(int k = 0; k <= K; ++k) {
                int &res = f[i][k];
                if(k) res = min(res, f[i - 1][k - 1]);
                int same = 0, diff = 0;
                for(int idx = i; idx >= 1; --idx) {
                    if(s[i] == s[idx]) {
                        ++same;
                        res = min(res, cal(same) + f[idx - 1][k - diff]);
                    } else {
                        ++diff;
                        if(diff > k) break;
                        res = min(res, cal(same) + f[idx - 1][k - diff]);
                    }
                }
            }
        }
        return f[n][K];
    }
    
    int cal(int count) {
        if(count == 1) return 1;
        string s = to_string(count);
        return s.size() + 1;
    }
};
```





### 二叉树中的最大路径和
给定一颗二叉树，求二叉树的直径。
1.该题的直径定义为：树上任意两个节点路径长度的最大值；
2.该题路径长度定义为：不需要从根节点开始，也不需要在叶子节点结束，也不需要必须从父节点到子节点，一个节点到底另外一个节点走的边的数目；
3.这个路径可能穿过根节点，也可能不穿过；
4.树为空时，返回 0；


思路类似于**树形DP**求直径。
```java
import java.util.*;

public class Solution {
    
    int ans = -(int)1e8;
    public int maxPathSum (TreeNode root) {
        // write code here
        dfs(root);
        return ans;
    }
    
    int dfs(TreeNode root) { // return 从这个节点（此节点的值必选）出发的路径的最大路径和
        if(root == null) return 0;
        int lv = dfs(root.left);
        int rv = dfs(root.right);
        ans = Math.max(ans, (lv > 0 ? lv : 0) + (rv > 0 ? rv : 0) + root.val); // 串上左右节点
        int cs = Math.max(lv, rv) > 0 ? Math.max(lv, rv) : 0; // 向左出发、向右出发
        return cs + root.val; // 本身的节点的值必选
    }
}
```



### 拼成金额的最小硬币数（完全背包）

有n种不同面值的硬币，硬币数量无限，组成指定金额，最少需要多少枚硬币。

```java
import java.util.*;

public class Solution {

    public int minMoney (int[] a, int t) {
        // write code here
        int N = 10010, M = 5010;
        int n = a.length;
        int[] f = new int[M];
        Arrays.fill(f, M);
        f[0] = 0;
        for(int i = 0; i < n; i++) { // 以硬币的枚举为阶段
            for(int j = a[i]; j <= t; j++) {
                f[j] = Math.min(f[j], f[j- a[i]] + 1);
            }
        }
        return f[t] >= M ? -1 : f[t];
    }
}
```



————————分割线————————



### 最大正方形
给定一个由'0'和'1'组成的2维矩阵，返回该矩阵中最大的由'1'组成的正方形的面积，输入的矩阵是字符形式而非数字形式。
数据范围：矩阵的长宽满足 0 \le n \le 200≤*n*≤20,矩阵中的元素属于 {'1','0'}
进阶：空间复杂度 O(n^2)*O*(*n*2) ， 时间复杂度 O(n^2)*O*(*n*2)

```java
import java.util.*;

public class Solution {
    /**
     * 最大正方形
     * @param matrix char字符型二维数组 
     * @return int整型
     */
    public int solve (char[][] matrix) {
        // write code here
        int m = matrix.length;
        if(m == 0) return 0;
        int n = matrix[0].length;
        if(n == 0) return 0;
        int maxLen = 1;
        int[][] f = new int[m][n];
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(matrix[i][j] == '1') {
                    int l1 = i > 0 ? f[i - 1][j] : 0;
                    int l2 = j > 0 ? f[i][j - 1] : 0;
                    int l3 = i > 0 && j > 0 ? f[i - 1][j - 1] : 0;
                    int l = Math.min(l1, Math.min(l2 ,l3));
                    f[i][j] = Math.max(1, l + 1);
                    maxLen = Math.max(maxLen, f[i][j]);
                }
            }
        }
        return maxLen * maxLen;
    }
}

// i, j l1 l2     
```



### 三角形最小路径和

给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是下标与上一层结点下标相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int[] f = new int[210]; // 滚动数组
        int len = triangle.size();
        // 从上往下转移
        for(int i = len - 1; i >= 0; i--) {
            for(int j = 0; j <= i; j++) {
                if(i == len - 1) {
                    f[j] = triangle.get(i).get(j);
                } else {
                    f[j] = Math.min(f[j], f[j + 1]) + triangle.get(i).get(j);
                }
            }
        }
        return f[0];
    }
}
```



### **合法的括号字符串**

https://www.nowcoder.com/practice/eceb50e041ec40bd93240b8b3b62d221?tpId=117&tqId=39331&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fdifficulty%3D3%26judgeStatus%3D3%26page%3D2%26pageSize%3D50%26search%3D%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=3&judgeStatus=3&tags=&title=



给定一个字符串s，字符串s只包含以下三种字符: (，*，)，请你判断 s是不是一个合法的括号字符串。合法括号字符串有如下规则:

1.左括号'('必须有对应的右括号')'

2.右括号')'必须有对应的左括号'('

3.左括号必须在对应的右括号前面

4.*可以视为单个左括号，也可以视为单个右括号，或者视为一个空字符

5.空字符串也视为合法的括号字符串

```cpp
#include <iostream>

using namespace std;

class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param s string字符串
     * @return bool布尔型
     */
    bool isValidString(string s) {
        int n = s.size();
        // write code here
        bool f[110][110]{};
        for (int len = 1; len <= n; ++len) {
            for (int i = 0; i + len <= n; ++i) {
                int j = i + len - 1;
                if (len == 1) {
                    f[i][i] = s[i] == '*';
                } else if (len == 2) {
                    f[i][j] = (s[i] == '(' || s[i] == '*') && (s[j] == ')' || s[j] == '*');
                } else {
                    bool &flag = f[i][j];
                    if (s[j] == ')' || s[j] == '*') {
                        // 嵌套
                        if (s[i] == '(' || s[i] == '*') {
                            flag = flag || f[i + 1][j - 1];
                        }
                        // 转移
                        for (int k = i; k < j; ++k) {
                            flag = flag || (f[i][k] && f[k + 1][j]);
                        }
                    }
                    if (s[j] == '*') {
                        flag = flag || f[i][j - 1];
                    }
                }
            }
        }
        return f[0][n - 1];
    }

};
```



> 参考链接 https://song-yang-ji.blog.csdn.net/article/details/117856984



参考上面的左右扫描两边的做法，得到如下做法：

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param s string字符串 
     * @return bool布尔型
     */
    bool isValidString(string s) {
        // write code here
        int l = 0, r = 0, t = 0;
        for(int i = 0; i < s.size(); ++i) {
            if(s[i] == '(') ++l;
            else if(s[i] == ')') ++r;
            else ++t;
            if(l + t < r) return false;
        }
        l = 0, r = 0, t = 0;
        for(int i = s.size() - 1; i >= 0; --i) {
            if(s[i] == '(') ++l;
            else if(s[i] == ')') ++r;
            else ++t;
            if(r + t < l) return false;
        }        
        return true;
    }
};
```





### **NC176** **打家劫舍(一)**

https://www.nowcoder.com/practice/c5fbf7325fbd4c0ea3d0c3ea6bc6cc79?tpId=117&tqId=39332&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fdifficulty%3D3%26judgeStatus%3D3%26page%3D2%26pageSize%3D50%26search%3D%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=3&judgeStatus=3&tags=&title=



你是一个经验丰富的小偷，准备偷沿街的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，即，如果偷了第一家，就不能再偷第二家；如果偷了第二家，那么就不能偷第一家和第三家。

给定一个整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。

数据范围：数组长度满足 1 $\le$ n $\le$ 2 $\times$ 10^5，数组中每个值满足 1 $\le$ num[i] $\le$ 5000 \1≤num[i]≤5000 

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @return int整型
     */
    int rob(vector<int>& nums) {
        // write code here
        int n = nums.size();
        vector<vector<int>> f(n, vector<int>(2));
        f[0][0] = 0;
        f[0][1] = nums[0];
        for(int i = 1; i < n; ++i) {
            f[i][0] = max(f[i - 1][0], f[i - 1][1]);
            f[i][1] = f[i - 1][0] + nums[i];   
        }
        return max(f[n - 1][0], f[n - 1][1]);
    }
};
```





### **NC177** **打家劫舍(二)**

https://www.nowcoder.com/practice/a5c127769dd74a63ada7bff37d9c5815?tpId=117&tqId=39333&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fdifficulty%3D3%26judgeStatus%3D3%26page%3D2%26pageSize%3D50%26search%3D%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=3&judgeStatus=3&tags=&title=



你是一个经验丰富的小偷，准备偷沿湖的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，即，如果偷了第一家，就不能再偷第二家，如果偷了第二家，那么就不能偷第一家和第三家。沿湖的房间组成一个闭合的圆形，即第一个房间和最后一个房间视为相邻。

给定一个长度为n的整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。

数据范围：数组长度满足 1 $\le$ n $\le$ 2 $\times$ 10^5，数组中每个值满足 1 $\le$ num[i] $\le$ 5000 \1≤num[i]≤5000 

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @return int整型
     */

    int f[200010][2];

    int rob(vector<int>& a) {
        // write code here
        int n = a.size();
        if(n == 1) {
            return a[0];
        }
        if(n == 2) {
            return max(a[0], a[1]);
        }
        int ans = 0;
        
        memset(f, 0, sizeof(f));
        for(int i = 1; i < n; ++i) {
            f[i][1] = f[i - 1][0] + a[i];
            f[i][0] = max(f[i - 1][0], f[i - 1][1]);
        }
        ans = max(f[n - 1][0], f[n - 1][1]);
        
        
        memset(f, 0, sizeof(f));
        f[0][0] = 0;
        f[0][1] = a[0];
        for(int i = 1; i < n; ++i) {
            if(i != n - 1) f[i][1] = f[i - 1][0] + a[i];
            f[i][0] = max(f[i - 1][0], f[i - 1][1]);
        }
        ans = max(max(f[n - 1][0], f[n - 1][1]), ans);
        return ans;
    }
};
```



循环依赖的怎么解？

在环的任意一处拆开来，将环转成链即可。



### **NC243** **目标和**

https://www.nowcoder.com/practice/7fc06e2162f048658252fac542fcb1e8?tpId=117&tqId=39588&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fdifficulty%3D3%26judgeStatus%3D3%26page%3D2%26pageSize%3D50%26search%3D%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=3&judgeStatus=3&tags=&title=



给定一个整数数组nums和一个整数target，请你返回该数组能构成多少种不同的表达式等于target。

规则如下：

1.将数组里每个整数前面可以添加"+"或者"-"符号，组成一个表达式，例如[1,2]，可以变成”+1+2","+1-2","-1+2","-1-2"，这四种

2.只能添加"+"与"-"符号，不能添加其他的符号

3.如果构不成等于target的表达式，请返回0

4.保证返回的结果个数在整数范围内



数据范围:

0<=nums.length<=200<=nums.length<=20

0<=nums[i]<=10000<=nums\[i\]<=1000

0<=sum(nums[i])<=10000<=sum(nums\[i\])<=1000

-1000<=target<=1000−1000<=target<=1000



```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @param target int整型 
     * @return int整型
     */
    int ans = 0;
    int findTargetSumWays(vector<int>& nums, int target) {
        if(nums.empty()) return ans;
        dfs(nums, target, 0, 0);
        // write code here
        return ans;
    }
    
    void dfs(vector<int>& nums, int target, int cur, int idx) {
        if(idx == nums.size()) {
            if(cur == target) ++ans;
            return;
        }
        dfs(nums, target, cur + nums[idx], idx + 1);
        dfs(nums, target, cur - nums[idx], idx + 1);
    }
};
```





```cpp
#include <iostream>
#include <vector>
#include <map>
#include <unordered_map>
using namespace std;

const int dx[] = {-1, 0, 1, 0};
const int dy[] = {0, 1, 0, -1};

class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @param target int整型 
     * @return int整型
     */
    
    vector<unordered_map<int, int>> st;

    int ans = 0;
    int findTargetSumWays(vector<int>& nums, int target) {
        if(nums.empty()) return 0;
        int n = nums.size();
        st.resize(n);
        // f[i][target] = f[i - 1][target - nums[i]] + f[i - 1][target + nums[i]]
        return dfs(n - 1, target, nums);
    }
    int dfs(int idx, int t, vector<int>& nums) {
        if(idx == -1) {
            if(t == 0) return 1;
            return 0;
        }
        if(st[idx].count(t)) {
            return st[idx][t];
        }
        int res = 0;
        res = dfs(idx - 1, t + nums[idx], nums) + dfs(idx - 1, t - nums[idx], nums);
        st[idx].emplace(t, res);
        return res;
    }
};

```



### **最长公共子数组**

https://www.nowcoder.com/practice/6032826d387c4a10ad3690cce5fdb015?tpId=117&tqId=39350&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fdifficulty%3D3%26judgeStatus%3D3%26page%3D2%26pageSize%3D50%26search%3D%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=3&judgeStatus=3&tags=&title=

给定两个整数数组，求两个数组的最长的公共子数组的长度。子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组

数据范围：两个数组的长度都满足 1 $\le$ n $\le$ 1000，数组中的值都满足 0 \le val \le 100 \0≤*v**a**l*≤100 

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param A int整型vector 
     * @param B int整型vector 
     * @return int整型
     */
    int longestCommonSubarry(vector<int>& a, vector<int>& b) {
        // write code here
        int ans = 0;
        int m = a.size(), n = b.size();
        vector<vector<int>> f(m + 10, vector<int>(n + 10));
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                if(a[i] == b[j]) {
                    f[i][j] = (i > 0 && j > 0 ? f[i - 1][j - 1] : 0) + 1;
                }
                ans = max(ans, f[i][j]);
            }
        }
        return ans;
    }
};
```



如果是最长公共子序列的话？

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param A int整型vector 
     * @param B int整型vector 
     * @return int整型
     */
    int longestCommonSubarry(vector<int>& a, vector<int>& b) {
        // write code here
        int m = a.size(), n = b.size();
        vector<vector<int>> f(m + 10, vector<int>(n + 10));
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                int &res = f[i][j];
                res = max(res, (i > 0 && j > 0 ? f[i - 1][j - 1] : 0) + (a[i] == b[j]));
                res = max(res, i > 0 ? f[i - 1][j] : 0);
                res = max(res, j > 0 ? f[i][j - 1] : 0);
            }
        }
        return f[m - 1][n - 1];
    }
};
```





### **NC181** **单词拆分(一)**

https://www.nowcoder.com/practice/c0d32c1ce5744472a01b2351a2c2767f?tpId=117&tqId=39348&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fdifficulty%3D3%26judgeStatus%3D3%26page%3D2%26pageSize%3D50%26search%3D%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=3&judgeStatus=3&tags=&title=



```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param s string字符串 
     * @param dic string字符串vector 
     * @return bool布尔型
     */
    bool wordDiv(string s, vector<string>& ss) {
        // write code here
        unordered_set<string> dic;
        for(auto &p: ss) {
            dic.insert(p);
        }
        int n = s.size();
        s = " " + s;
        vector<int> f(n + 10);
        f[0] = true;
        for(int i = 1; i <= n; ++i) {
            for(int j = 0; j < i; ++j) {
                // j + 1, i
                string tmp = s.substr(j + 1, i - j);
                if(dic.count(tmp) && f[j]) {
                    f[i] = f[i] || f[j];
                }
            }
        }
        return f[n];
    }
};
```



### **NC83** **连续子数组的最大乘积**

https://www.nowcoder.com/practice/abbec6a3779940aab2cc564b22d36859?tpId=117&tqId=37785&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fdifficulty%3D3%26judgeStatus%3D3%26page%3D1%26pageSize%3D50%26search%3D%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=3&judgeStatus=3&tags=&title=



输入一个长度为n的整型数组nums，数组中的一个或连续多个整数组成一个子数组。求所有子数组的乘积的最大值。

1.子数组是连续的，且最小长度为1，最大长度为n

2.长度为1的子数组，乘积视为其本身，比如[4]的乘积为4

3.该题的数据保证最大的乘积不会超过int的范围，即不超过2^{32}-1232−1

数据范围:

1<=*n*<=2×105

-100 <= a[i] <= 100−100<=*a*[*i*]<=100

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * @param a int整型vector
     * @return int整型
     */
    int maxProduct(vector<int> &a) {
        vector<int> pos(a); // 存储以 a[i] 结尾的最大乘积
        vector<int> neg(a); // 存储以 a[i] 结尾的最小乘积
        int result = a[0];
        for (int i = 1; i < a.size(); i++) {
            pos[i] = max(a[i], max(a[i] * pos[i - 1], a[i] * neg[i - 1]));
            neg[i] = min(a[i], min(a[i] * pos[i - 1], a[i] * neg[i - 1]));
            result = max(result, pos[i]);
        }
        return result;
    }
};
```





### **NC138** **矩阵最长递增路径**

https://www.nowcoder.com/practice/7a71a88cdf294ce6bdf54c899be967a2?tpId=117&tqId=37850&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fdifficulty%3D3%26judgeStatus%3D3%26page%3D1%26pageSize%3D50%26search%3D%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=3&judgeStatus=3&tags=&title=



给定一个 n 行 m 列矩阵 matrix ，矩阵内所有数均为非负整数。 你需要在矩阵中找到一条最长路径，使这条路径上的元素是递增的。并输出这条最长路径的长度。

这个路径必须满足以下条件：

1. 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外。

2. 你不能走重复的单元格。即每个格子最多只能走一次。

数据范围：1 < n,m < 1000，0 < matrix\[i]\[j\] < 10000≤matrix\[i\]\[j\]≤1000


```cpp
const int N = 1010;
const int dx[] = {1, 0, -1, 0};
const int dy[] = {0, 1, 0, -1};

class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 递增路径的最大长度
     * @param matrix int整型vector<vector<>> 描述矩阵的每个数
     * @return int整型
     */
    bool vis[N][N]{}; // not necessary
    int f[N][N]{};
    int m, n;
    int solve(vector<vector<int> >& g) {
        // write code here
        m = g.size();
        n = g[0].size();
        int ans = 0;
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
//                 memset(vis, 0, sizeof(vis));  error code
                ans = max(ans, dfs(i, j, g));
            }
        }
        return ans;
    }
    
    int dfs(int x, int y, vector<vector<int>> &g) {
        if(f[x][y]) return f[x][y];
        int &res = f[x][y];
        res = 1;
//         vis[x][y] = 1;
        for(int k = 0; k < 4; ++k) {
            int nx = x + dx[k];
            int ny = y + dy[k];
            if(nx >= 0 && nx < m && ny >= 0 && ny < n) {
                if(g[nx][ny] > g[x][y]) {
                    res = max(res, 1 + dfs(nx, ny, g));
                }
            }
        }
//         vis[x][y] = 0;
        return res;
    }
    
};
```