---
title: JVM内存结构
date: 2021-12-12 18:31:40
categories: JVM
tags:
  - Java
  - JVM
---



## JVM内存结构图

《深入理解Java虚拟机（第2版）》

![](jvm-memory.jpg)



**Java8内存结构介绍**



![图片](jvm-memory2.png)



## 虚拟机内存与本地内存的区别

Java虚拟机在执行的时候会把管理的内存分配成不同的区域，这些区域被称为虚拟机内存，同时，对于虚拟机没有直接管理的物理内存，也有一定的利用，这些被利用却不在虚拟机内存数据区的内存，我们称它为`本地内存`，这两种内存有一定的区别：

+ JVM内存
  受虚拟机内存大小的参数控制，当大小超过参数设置的大小时就会报OOM

+ 本地内存
  本地内存不受虚拟机内存参数的限制，只受物理内存容量的限制
  虽然不受参数的限制，但是如果内存的占用超出物理内存的大小，同样也会报OOM



## 各个区域的具体作用

### 程序计数器（Program Counter Register）

**程序计数器就是当前线程所执行的字节码的行号指示器**，**通过改变计数器的值，来选取下一行指令**，通过他来实现跳转、循环、恢复线程等功能。

+ 在任何时刻，一个处理器内核只能运行一个线程，多线程是通过线程轮流切换，分配时间来完成的，这就需要有一个标志来记住每个线程执行到了哪里，这里便需要到了程序计数器。
+ 所以，**程序计数器是线程私有的**，每个线程都已自己的程序计数器。




### 虚拟机栈（JVM Stacks）
虚拟机栈是线程私有的，随线程生灭。虚拟机栈描述的是线程中的方法的内存模型：

每个方法被执行的时候，都会在虚拟机栈中同步创建一个**栈帧**（stack frame）。

+ 每个栈帧的包含如下的内容
  + Java基本数据类型（byte/boolean/char/int/long/double/float/short）以及对象的引用 （注：这里的基本数据类型指的是方法内的局部变量）
  + 局部变量表
  + 操作数栈
  + 动态连接
  + 方法返回地址


方法被执行时入栈，执行完后出栈
虚拟机栈可能会抛出两种异常：

+ 如果线程请求的栈深度大于虚拟机所规定的栈深度，则会抛出`StackOverFlowError`即栈溢出
+ 如果虚拟机的栈容量可以动态扩展，那么当虚拟机栈申请不到内存时会抛出`OutOfMemoryError`即OOM内存溢出



### 本地方法栈（Native Method Stacks）

本地方法栈与虚拟机栈的作用是相似的,都会抛出`OutOfMemoryError`和`StackOverFlowError`，都是`线程私有`的，主要的区别在于：

+ 虚拟机栈执行的是java方法
+ 本地方法栈执行的是native方法



### Java堆（Java Heap）
java堆是JVM内存中最大的一块，由所有**线程共享**,是**由垃圾收集器管理**的内存区域，**主要存放对象实例**，当然由于java虚拟机的发展，堆中也多了许多东西，现在主要有：

+ 对象实例
  + 类初始化生成的对象；
  + 基本数据类型的数组也是对象实例。
+ 字符串常量池
  + 字符串常量池原本存放于方法区，jdk7开始放置于堆中；
  + 字符串常量池存储的是string对象的直接引用，而不是直接存放的对象，是一张`string table`。

+ 静态变量
  静态变量是有static修饰的变量，jdk7时从方法区迁移至堆中。

+ 线程分配缓冲区（Thread Local Allocation Buffer）
  + 线程私有，但是不影响java堆的共性；
  + 增加线程分配缓冲区是为了提升对象分配时的效率。

java堆既可以是固定大小的，也可以是可扩展的（通过参数`-Xmx`和`-Xms`设定），如果堆无法扩展或者无法分配内存时也会报OOM。

> 静态变量 存储位置：JDK8之前，静态成员变量确实存放在方法区；但JDK8之后就取消了“永久代”，取而代之的是“元空间”，永久代中的数据也进行了迁移，静态成员变量迁移到了堆中（方法区是JVM的规范，永久代是方法区的具体实现）。




### 方法区（Method Area）

方法区绝对是网上所有关于java内存结构文章争论的焦点，因为方法区的实现在java8做了一次大革新，现在我们来讨论一下：

**方法区是所有线程共享的内存**，

在java8以前是放在JVM内存中的，**由永久代实现，受JVM内存大小参数的限制**;

在java8中移除了永久代的内容，**方法区由元空间(Meta Space)实现，并直接放到了本地内存中**，不受JVM参数的限制（当然，如果物理内存被占满了，方法区也会报OOM）。

并且将原来放在方法区的**字符串常量池**和**静态变量**都转移到了Java堆中，方法区与其他区域不同的地方在于，方法区在编译期间和类加载完成后的内容有少许不同，不过总的来说分为这两部分：

+ 类元信息（Klass）
  + 类元信息在类编译期间放入方法区，里面放置了类的基本信息，包括类的`版本`、`字段`、`方法`、`接口`以及`常量池表（Constant Pool Table）`
  + `常量池表（Constant Pool Table）`存储了类在编译期间生成的`字面量`、`符号引用`这些信息在类加载完后会被解析到运行时常量池中

+ 运行时常量池（Runtime Constant Pool）
  + **运行时常量池主要存放在类加载后被解析的字面量与符号引用**，但不止这些；
  + 运行时常量池具备动态性，可以添加数据，比较多的使用就是String类的intern()方法



## 直接内存

**直接内存位于本地内存，不属于JVM内存**，但是也会在物理内存耗尽的时候报OOM。

在jdk1.4中加入了NIO（New Input/Putput）类，引入了一种基于通道（channel）与缓冲区（buffer）的新IO方式，它可以使用native函数直接分配堆外内存，然后通过存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样可以在一些场景下大大提高IO性能，**避免了在java堆和native堆来回复制数据**。



# 常见问题


## 类常量池、运行时常量池、字符串常量池有什么关系？有什么区别？
类常量池与运行时常量池都存储在方法区，而**字符串常量池在jdk7时就已经从方法区迁移到了java堆中**。

在类编译过程中，会把类元信息放到方法区，类元信息的其中一部分便是**类常量池，主要存放字面量和符号引用**，**而字面量的一部分便是文本字符**，在类加载时将字面量和符号引用解析为直接引用存储在运行时常量池；

对于文本字符来说，它们会在解析时查找字符串常量池，查出这个文本字符对应的字符串对象的直接引用，将直接引用存储在运行时常量池；

**字符串常量池存储的是字符串对象的引用，而不是字符串本身**。





## 什么是字面量？什么是符号引用？



+ 字面量

  ```java
  int a=1;//这个1便是字面量
  String b="iloveu";//iloveu便是字面量
  ```

+ + java代码在编译过程中是无法构建引用的，字面量就是在编译时对于数据的一种表示:

+ 符号引用

+ + 由于在编译过程中并不知道每个类的地址，因为可能这个类还没有加载，所以如果你在一个类中引用了另一个类，那么你完全无法知道他的内存地址，那怎么办，我们只能用他的类名作为符号引用，在类加载完后用这个符号引用去获取他的内存地址。
  + 例子：我在com.demo.Solution类中引用了com.test.Quest，那么我会把`com.test.Quest`作为符号引用存到类常量池，等类加载完后，拿着这个引用去方法区找这个类的内存地址。



> 参考
>
> [jvm系列(二):JVM内存结构](https://www.cnblogs.com/ityouknow/p/5610232.html)



