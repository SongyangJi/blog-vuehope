---
title: 《刷题——链表》
date: 2023-01-09 04:28:05
categories: 算法题
tags:
---



## 链表
### 链表中的节点每k个一组翻转
题：将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表
如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样
你不能更改节点中的值，只能更改节点本身。

```java
class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    int len(ListNode* head) {
        int cnt = 0;
        while(head) {
            ++cnt;
            head = head->next;
        }
        return cnt;
    }
    
    ListNode* reverseKGroup(ListNode* head, int k) {
        // write code here
        ListNode *dum = new ListNode(-1), *cur = dum;
        ListNode* p = head;
        while(p) {
            int l = len(p);
            if(l < k) {
                cur->next = p;
                break;
            }
            ListNode *res = nullptr, *q = p;
            // 头插
            for(int i = 0; i < k; i++) {
                auto nxt = q->next;
                q->next = res;
                res = q;
                q = nxt;
            }
            cur->next = res; // 接上
            cur = p; // cur 移动
            p = q; // p 移动
        }
        return dum->next;
    }
};
```



```java
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* dumb = new ListNode();
        dumb->next = head;
        ListNode *pre = dumb, *end = dumb;
        while (end->next != nullptr) {
            for (int i = 0; i < k && end != nullptr; ++i) {
                end = end->next;
            }
            if (end == nullptr) break;
            ListNode* nxt = end->next; // 拿到后继
            ListNode* start = pre->next; // 拿到头
            end->next = nullptr; // 断开
            pre->next = reverse(start); // 反转
            start->next = nxt; // 接上链表
            pre = end = start; // “头”变成”尾“，从这出发
        }
        return dumb->next;
    }
    
    ListNode* reverse(ListNode* head) {
        ListNode* pre = nullptr, *cur = head;
        while (cur != nullptr) {
            ListNode* nxt = cur->   next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }
};
```








### 判断链表中是否有环（快慢指针）
```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null) return false;
        ListNode slow = head, fast = head;
        while(fast != null) {
            slow = slow.next;
            fast = fast.next;
            if(fast != null) fast = fast.next;
            if(fast == slow) return true; // 检查
        }
        return false;
    }
}
```



### 环的入口
[题解](https://song-yang-ji.blog.csdn.net/article/details/108997251)
```java
public class Solution {

    public ListNode EntryNodeOfLoop(ListNode pHead) {
        if(pHead == null || pHead.next == null) return null;
        ListNode slow = pHead, fast = pHead;
        while(fast != null) {
            slow = slow.next;
            fast = fast.next;
            if(fast != null) fast = fast.next;
            if(slow == fast) {
                ListNode cur = pHead;
                // a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)
                // a == c
                while(cur != slow) {
                    cur = cur.next;
                    slow = slow.next;
                }
                return cur;
            }
        }
        return null;
    }
}
```

### 链表相交

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) return null;
        ListNode pA = headA, pB = headB;
        // a + c + b == b + c + a (c是公共部分)
        while (pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
}
```



### 删除给出链表中的重复元素
**删除给出链表中的重复元素**（链表中元素从小到大有序），**使链表中的所有元素都只出现一次**

```java
import java.util.*;

public class Solution {

    public ListNode deleteDuplicates (ListNode head) {
        // write code here
        ListNode p = head;
        if(p == null) return head;
        while(p.next != null) {
            if(p.val == p.next.val) {
                p.next = p.next.next;
            } else {
                p = p.next;
            }
        }
        return head;
    }
}
```


**删除给出链表中的重复元素，一个也不留**（链表中元素从小到大有序）
**删除有序链表中重复的元素-II**
```java
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* dum = new ListNode, *cur = dum;
        ListNode* p = head;
        while(p) {
            int val = p->val;
            if(p->next && p->next->val == val) {
                ListNode* q = p;
                while(q && q->val == val) {
                    q = q->next;
                }
                p = q;
            } else {
                ListNode* q = p->next;
                p->next = nullptr; // 断开
                cur->next = p;
                cur = p;
                p = q;
            }
        }
        return dum->next;
    }
};
```



### K路归并问题

[23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

+  堆
**k路归并问题**
时间复杂度:$O(kn*log(k))$


```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
private:
    struct Node {
        ListNode* p;
        Node(ListNode*p):p(p){}
        bool operator<(const Node& b) const{
            return p->val>b.p->val;
        } 
    };
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode* preHead = new ListNode; //哨兵
        ListNode* pre = preHead;
        priority_queue<Node> pq;
        for(int i=0;i<lists.size();i++){
            if(lists[i]) pq.push(Node(lists[i]));
        }
        while(pq.size()){
            Node node = pq.top();
            pq.pop();
            pre->next = node.p;
            pre = pre->next; // 尾插
            if(node.p->next){
                pq.push(Node(node.p->next));
            }
        }
        return preHead->next;
    }
};
```

+ 分治算法
如果两两合并的话，时间复杂度 $O(k^2*n)$


分治的话：一次合并区间的一半。就像是**归并排序**一样。
时间复杂度：$O(k*log(k)*n)$

```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return devide_conquer(lists,0,(int)lists.size()-1);
    }

    ListNode* devide_conquer(vector<ListNode*>& lists,int l,int r){
        if(l==r) return lists[l];
        if(l>r) return nullptr;
        int mid = l + (r - l)/2;
        // 和归并排序一样的做法,先处理一半，再合并到一起
        ListNode* left = devide_conquer(lists, l, mid)
        ListNode* right = devide_conquer(lists, mid + 1, r);
        return mergeTwoLists(left,right);
    }

    // 双链合并的标准写法写法 
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* preHead = new ListNode; // 哨兵
        ListNode* pre = preHead;  // 移动的哨兵
        while(l1 && l2){
            if(l1->val<l2->val){
                pre->next = l1;
                l1 = l1->next;
            }else{
                pre->next = l2;
                l2 = l2->next;
            }
            pre = pre->next;
        }
        pre->next = (l1 ? l1 : l2);
        return preHead->next;
    }
};
```


**多路归并**
```java
import java.util.*;

public class Solution {
    public ListNode mergeKLists(ArrayList<ListNode> lists) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>((o1, o2) -> o1.val - o2.val);
        for(ListNode node : lists) {
            if(node != null) pq.offer(node);
        }
        ListNode dum = new ListNode(-1), cur = dum;
        while(pq.size() > 0) {
            ListNode node = pq.poll();
            cur.next = node;
            cur = node;
            if(node.next != null) {
               pq.offer(node.next);
            }
        }
        return dum.next;
    }
}
```