---
title: 操作系统——页面置换算法
date: 2022-09-23 01:46:02
categories: 操作系统
tags:
---



## 缺页中断

当 CPU 访问的⻚⾯不在物理内存时，便会产⽣⼀个缺⻚中断，请求操作系统将所缺⻚调⼊到物理内存。那它与⼀般中断的主要区别在于：
缺⻚中断在指令执⾏「期间」产⽣和处理中断信号，⽽⼀般中断在⼀条指令执⾏「完成」后检查和处理中断信号。

缺⻚中断返回到该指令的开始重新执⾏「该指令」，⽽⼀般中断返回回到该指令的「下⼀个指令」执⾏。


1. 在 CPU ⾥访问⼀条 Load M 指令，然后 CPU 会去找 M 所对应的⻚表项。
2. 如果该⻚表项的状态位是「有效的」，那 CPU 就可以直接去访问物理内存了，如果状态位是「⽆效的」，则 CPU 则会发送缺⻚中断请求。
3. 操作系统收到了缺⻚中断，则会执⾏缺⻚中断处理函数，先会查找该⻚⾯在磁盘中的⻚⾯的位置。
4. 找到磁盘中对应的⻚⾯后，需要把该⻚⾯换⼊到物理内存中，**但是在换⼊前，需要在物理内存中找空闲⻚**，如果找到空闲⻚，就把⻚⾯换⼊到物理内存中。
5. ⻚⾯从磁盘换⼊到物理内存完成后，则把⻚表项中的状态位修改为「有效的」。
6. 最后，CPU 重新执⾏导致缺⻚异常的指令。



上⾯所说的过程，第 4 步是能在物理内存找到空闲⻚的情况，那如果找不到呢？

找不到空闲⻚的话，就说明此时内存已满了，这时候，就需要「⻚⾯置换算法」选择⼀个物理⻚，如果该

物理⻚有被修改过（脏⻚），则把它换出到磁盘，然后把该被置换出去的⻚表项的状态改成「⽆效的」，

最后把正在访问的⻚⾯装⼊到这个物理⻚中。



所以，**⻚⾯置换算法的功能**是，**当出现缺⻚异常，需调⼊新⻚⾯⽽内存已满时，选择被置换的物理⻚⾯，**

**也就是说选择⼀个物理⻚⾯换出到磁盘，然后把需要访问的⻚⾯换⼊到物理⻚。**

那其算法⽬标则是，**尽可能减少⻚⾯的换⼊换出的次数**，常⻅的⻚⾯置换算法有如下⼏种：



常⻅的⻚⾯置换算法有如下⼏种：

1. 最佳⻚⾯置换算法（*OPT*）

2. 先进先出置换算法（*FIFO*）最近最久未使⽤的置换算法（*LRU*）

3. 时钟⻚⾯置换算法（*Lock*）

4. 最不常⽤置换算法（*LFU*）




### 最佳⻚⾯置换算法OPT
最佳⻚⾯置换算法基本思路是，**置换在「未来」最⻓时间不访问的⻚⾯**。

这很理想，但是实际系统中⽆法实现，因为程序访问⻚⾯时是动态的，我们是⽆法预知每个⻚⾯在「下⼀次」访问前的等待时间。

所以，最佳⻚⾯置换算法作⽤是为了衡量你的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是⾼效的。




### 先进先出置换算法FIFO
既然我们⽆法预知⻚⾯在下⼀次访问前所需的等待时间，那我们可以**选择在内存驻留时间很⻓的⻚⾯进⾏中置换**，这个就是「先进先出置换」算法的思想。




### 最近最少使⽤的置换算法LRU

最近最少使⽤（*LRU*）的置换算法的基本思路是，发⽣缺⻚时，选择最⻓时间没有被访问的⻚⾯进⾏置换，也就是说，**该算法假设已经很久没有使⽤的⻚⾯很有可能在未来较⻓的⼀段时间内仍然不会被使⽤**。

这种算法近似最优置换算法，最优置换算法是通过「未来」的使⽤情况来推测要淘汰的⻚⾯，⽽ LRU 则是通过「历史」的使⽤情况来推测要淘汰的⻚⾯。

虽然 LRU 在理论上是可以实现的，但代价很⾼。为了完全实现 LRU，需要在内存中维护⼀个所有⻚⾯的链表，最近最多使⽤的⻚⾯在表头，最近最少使⽤的⻚⾯在表尾。
困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到⼀个⻚⾯，删除它，然后把它移动到表头是⼀个⾮常费时的操作。

> 所以，LRU 虽然看上去不错，但是由于开销⽐较⼤，实际应⽤中⽐较少使⽤。


### 时钟⻚⾯置换算法——Clock算法

简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。

当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。

对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。

当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。

**每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换**；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。

由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。

### 改进型的 clock 算法
CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。

这样，每一帧都处于以下四种情况之一：

1. 最近未被访问，也未被修改(u=0, m=0)。
2. 最近被访问，但未被修改(u=1, m=0)。
3. 最近未被访问，但被修改(u=0, m=1)。
4. 最近被访问，被修改(u=1, m=1)。



改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。**由于修改过的页在被替换之前必须写回**，因而这样做会节省时间。


### 最不常⽤页面置换算法
当发⽣缺⻚中断时，选择「访问次数」最少的那个⻚⾯，并将其淘汰。
它的实现⽅式是，对每个⻚⾯设置⼀个「访问计数器」，每当⼀个⻚⾯被访问时，该⻚⾯的访问计数器就累加 1。在发⽣缺⻚中断时，淘汰计数器值最⼩的那个⻚⾯。





# 页面抖动(颠簸)和工作集(驻留集)

## 页面抖动（颠簸）

在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。

如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。

频繁的发生缺页中断（抖动），其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。

虚拟内存技术可以在内存中保留更多的进程以提髙系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。

但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。

## 工作集（驻留集）

工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。

经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。

工作集模型的原理是：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。

如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。

正确选择工作集的大小，对存储器的利用率和系统吞吐量的提嵩，都将产生重要影响。