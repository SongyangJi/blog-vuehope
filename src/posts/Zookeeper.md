---
title: Zookeeper
date: 2022-09-26 11:01:58
tags:
---



# 节点类型

1.持久节点(PERSISTENT)
持久节点，创建后一直存在，直到主动删除此节点。

2.持久顺序节点(PERSISTENT_SEQUENTIAL)
持久顺序节点，创建后一直存在，直到主动删除此节点。在ZK中，每个父节点会为它的第一级子节点维护一份时序，记录每个子节点创建的先后顺序。

3.临时节点(EPHEMERAL)
临时节点在客户端会话失效后节点自动清除。临时节点下面不能创建子节点。

4.临时顺序节点(EPHEMERAL_SEQUENTIAL)
临时节点在客户端会话失效后节点自动清除。临时节点下面不能创建子节点。父节点getChildren会获得顺序的节点列表。





# 有哪几种角色

1. Leader

（1）事务请求的唯一调度和处理者，保证集群事务处理的顺序性

（2）集群内部各服务的调度者

2. Follower

（1）处理客户端的非事务请求，转发事务请求给 Leader 服务器

（2）参与事务请求 Proposal 的投票

（3）参与 Leader 选举投票

3. Observer

3.3.0 版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提升集群的非事务处理能力

（1）处理客户端的非事务请求，转发事务请求给 Leader 服务器

（2）不参与任何形式的投票





# 使用案例

+ 服务注册与订阅（共用节点）
+ 分布式通知（监听znode）
+ 服务命名（znode特性）
+ 数据订阅、发布（watcher）
+ 分布式锁（临时节点）



## 分布式屏障（通知）
分布式系统使用*障碍*来阻止对一组节点的处理，直到满足一个条件，此时所有节点都被允许继续进行。在 ZooKeeper 中通过指定一个屏障节点来实现屏障。如果屏障节点存在，则屏障就位。这是伪代码：

1. 客户端在屏障节点上调用 ZooKeeper API 的**exists()函数，并将***watch*设置为 true。
2. 如果**exists()**返回 false，则障碍消失，客户端继续
3. 否则，如果**exists()**返回 true，则客户端等待 ZooKeeper 为屏障节点发送监视事件。
4. 当 watch 事件被触发时，客户端重新发出**exists()**调用，再次等待直到屏障节点被移除。





## 分布式锁

全局同步的完全分布式锁，这意味着在任何时间快照中，没有两个客户端认为他们持有相同的锁。这些可以使用 ZooKeeper 来实现。与优先级队列一样，首先定义一个锁节点。



> ZooKeeper recipes 目录中现在存在一个 Lock 实现。这与发布工件的发布 - zookeeper-recipes/zookeeper-recipes-lock 目录一起分发。

希望获得锁的客户端执行以下操作：

1. 使用路径名为“ *locknode* /guid-lock-”并设置*序列*和*临时*标志调用**create() 。**如果缺少 create() 结果，则需要该*guid 。*请参阅下面的注释。
2. *在不*设置监视标志的情况下在锁定节点上调用**getChildren()**（这对于避免羊群效应很重要）。
3. 如果在步骤**1**中创建的路径名具有最小的序列号后缀，则客户端具有锁定并且客户端退出协议。
4. 客户端调用**exists( )**并在锁定目录中的路径上设置了监视标志，并具有下一个最低序列号。
5. 如果**exists( )**返回null，则转到步骤**2**。否则，请等待上一步的路径名通知，然后再转到第**2**步。

解锁协议非常简单：希望释放锁的客户端只需删除他们在步骤 1 中创建的节点。

这里有几点需要注意：

+ 删除一个节点只会导致一个客户端唤醒，因为每个节点都被一个客户端监视。通过这种方式，您可以避免羊群效应。
+ 没有轮询或超时。
+ 由于您实现锁定的方式，很容易看到锁定争用、中断锁定、调试锁定问题等的数量。