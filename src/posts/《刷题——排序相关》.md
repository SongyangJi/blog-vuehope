---
title: 《刷题——排序相关》
date: 2023-01-09 14:45:22
categories: 算法题
tags:
---



## 快排

### 裸快排

```java
import java.util.*;

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 将给定数组排序
     * @param arr int整型一维数组 待排序的数组
     * @return int整型一维数组
     */
    public int[] MySort (int[] arr) {
        // write code here
        qsort(arr, 0 , arr.length - 1);
        return arr;
    }
    
    void qsort(int[] a, int l, int r) {
        if(l >= r) return;
        int i = l - 1, j = r + 1, x = a[(l + r)/2];
        while(i < j) {
            do {++i;} while(a[i] < x); // 每次必移动；不等号
            do {--j;} while(a[j] > x);
            // 移动结束 a[j] <= x
            if(i < j) {
                int temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
        // j 是临界点
        qsort(a, l, j); // 都小于等于 注意 base a[j] <= x
        qsort(a, j + 1, r); // 都大于 base
    }
    
}
```



### 前K大

```java
import java.util.*;

public class Solution {
    ArrayList<Integer> ans = new ArrayList<>();
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        help(input, 0, input.length - 1, k);
        return ans;
    }
    
    void help(int[] a,int l, int r, int k) {
        if(l > r || k <= 0) return; // 终点
        int i  = l - 1, j = r + 1, x = a[(l + r)/2];
        while(i < j) {
            do {i++;} while(a[i] < x);
            do {j--;} while(a[j] > x);
            if(i < j) {
                int t = a[i]; a[i] = a[j]; a[j] = t;
            }
        }
        
        int idx = j;
        int cnt = 0;
        if(k >= idx - l + 1) { // 注意带 = 号
            for(int m = l; m <= idx; m++) {
                cnt++;
                ans.add(a[m]);
            }
            help(a, j + 1, r, k - cnt);
        } else {
            help(a, l, j, k); // 继续在前面筛选
        }
    }
    
}
```



### 第 K 大

```java
import java.util.*;

public class Solution {
    public int findKth(int[] a, int n, int K) {
        // write code here
        return help(a, 0, n - 1, n - K + 1); // 第 K 大 对应 n - K + 1
    }

    int help(int[] a, int l, int r, int K) {
        if (l >= r) return a[l];
        int i = l - 1, j = r + 1, x = a[(l + r) / 2];
        while (i < j) {
            do {
                ++i;
            } while (a[i] < x);
            do {
                --j;
            } while (a[j] > x);
            if (i < j) {
                int t = a[i];
                a[i] = a[j];
                a[j] = t;
            }
        }
        int cnt = (j - l + 1);
        // O(n) notice: K <= cnt
        return K <= cnt ? help(a, l, j, K) : help(a, j + 1, r, K - cnt);
    }
}
```





[排序链表 (归并排序、自顶而下、自底而上)](https://song-yang-ji.blog.csdn.net/article/details/109953484)


### 链表快排

**链表快排**
NC70 单链表的排序

```java
class Solution {


    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode l1 = null;    
        ListNode l2 = null;
        ListNode p = head;

        int x = head.val, y = head.val;
        while(p != null) {
            x = Math.min(x, p.val);
            y = Math.max(y, p.val);
            p = p.next;
        }
        if(x == y) return head;

        double base = (x+y)/2.0;

        // 链表的partition其实更简单一点
        // 这里使用头插法即可
        p = head;
        while(p != null) {
            ListNode q = p.next;
            if(p.val <= base) {
                p.next = l1;
                l1 = p;
            } else {
                p.next = l2;
                l2 = p;
            }
            p = q;
        }
        // 两条链表至少有一个元素，最好情况是各分一半
        l1 = sortList(l1); // l1的尾巴是 null
        l2 = sortList(l2); // l2的尾巴是 null
        // 两条链表接起来（如果是数组的话，无需这一步）
        p = l1;
        ListNode tail1 = p;
        while(p != null) {
            tail1 = p;
            p = p.next;
        }
        tail1.next = l2;
        return l1;
    }

}
```


**归并排序**

```java
import java.util.*;

public class Solution {
    /**
     * 
     * @param head ListNode类 the head node
     * @return ListNode类
     */
    public ListNode sortInList (ListNode head) {
        // write code here
        if(head == null || head.next == null) return head; // 终点
        // 快慢指针找到中点
        ListNode slow = head, fast = head, preMid = null;
        while(fast != null) {
            preMid = slow;
            slow = slow.next;
            fast = fast.next;
            if(fast != null) fast = fast.next;
        }
        preMid.next = null; // 从中间断开来
        return merge(sortInList(head),sortInList(slow));
    }
    // 两条链表的合并
    ListNode merge(ListNode l1, ListNode l2) {
        ListNode dum = new ListNode(-1), cur = dum;
        while(l1 != null && l2 != null) {
            if(l1.val < l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next; // notice
        }
        cur.next = l1 != null ? l1 : l2;
        return dum.next;
    }
}
```



## 归并排序



### 数组中的逆序对

```cpp
#include<bits/stdc++.h>

using namespace std;

int n, a[100010];

long long solve(int l, int r) {
    if (l >= r) return 0;

    int mid = (l + r) / 2;
    long long res = solve(l, mid) + solve(mid + 1, r);

    vector<int> v;

    int i = l;
    int j = mid + 1;

    while (i <= mid && j <= r) {
        if (a[i] <= a[j]) {
            v.push_back(a[i++]);
            res += j - (mid + 1); // key
        } else {
            v.push_back(a[j++]);
        }
    }

    while (i <= mid) {
        v.push_back(a[i++]);
        res += j - (mid + 1);
    }

    while (j <= r) v.push_back(a[j++]);

    int idx = l;
    for (int x:v) a[idx++] = x;

    return res;
}


int main() {
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
    cout << solve(0, n - 1) << endl;
    return 0;
}
```



**比较好的写法**

```java
public class Solution {
    int N = 1000000007;
    long ans = 0;
    int[] a, b;
    int n;
    public int InversePairs(int [] array) {
        this.a = array;
        this.n = array.length;
        this.b = new int[n];
        help(0, n - 1);
        ans = ans % N;
        return (int)ans;
    }
    
    void help(int l, int r) {
        if(l >= r) return;
        int m = l + (r - l)/2;
        // 分
        help(l, m);
        help(m + 1, r);
        // 合（二路归并 + 统计）
        int i = l, j = m + 1;
        for(int k = l; k <= r; k++) {
            if(j > r || (i <= m && a[i] <= a[j])) { // 注意是小于等于
                b[k] = a[i++];
            }
            else {
                ans = (ans + m - i + 1) % N;      // a[i]比a[j]大，则i~m都比a[j]大
                b[k] = a[j++];
            }
        }
        // b 是临时数组
        for(int k = l; k <= r; k++) {
            a[k] = b[k];
        }
    } 
}
```





### 拼接字符串求最大（排序）

给定一个长度为n的数组nums，数组由一些非负整数组成，现需要将他们进行排列并拼接，每个数不可拆分，使得最后的结果最大，返回值需要是string类型，否则可能会溢出。

数据范围：1≤n≤100，0 < nums[i] < 100000

进阶：时间复杂度O(nlogn) ，空间复杂度：O(n)

```java
import java.util.*;
import java.util.function.Consumer;

public class Solution {
    public String solve(int[] nums) {
        // write code here
        ArrayList<String> list = new ArrayList<>();
        for(int x:nums) {
            list.add(x+"");
        }
        list.sort((o1, o2) -> -(o1 + o2).compareTo(o2 + o1));
        // 防止多个 0 出现
        if(list.get(0).equals("0")) return "0";
        StringBuilder sb = new StringBuilder();
        list.forEach(sb::append);
        return sb.toString();
    }
}
```

 cpp版

```cpp
class Solution {
public:
    string solve(vector<int> nums) {
        auto cmp = [](int x, int y) {
            string sx = to_string(x);
            string sy = to_string(y);
            return sx + sy > sy + sx;
        };
        sort(nums.begin(), nums.end(), cmp);
        string ans;
        for (auto x:nums) {
            ans += to_string(x);
        }
        return ans;
    }
};
```