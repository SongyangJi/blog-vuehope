---
title: hertz——中间件
date: 2022-12-09 15:21:02
categories: hertz
tags:
---



源码分析

```go
// Use attaches a global middleware to the router. ie. the middleware attached though Use() will be
// included in the handlers chain for every single request. Even 404, 405, static files...
//
// For example, this is the right place for a logger or error management middleware.
func (engine *Engine) Use(middleware ...app.HandlerFunc) IRoutes {
	engine.RouterGroup.Use(middleware...)
	engine.rebuild404Handlers()
	engine.rebuild405Handlers()
	return engine
}
```



```go
type HandlerFunc func(c context.Context, ctx *RequestContext)
```



```go
// HandlersChain defines a HandlerFunc array.
type HandlersChain []HandlerFunc
```



```go
// Use adds middleware to the group, see example code in GitHub.
func (group *RouterGroup) Use(middleware ...app.HandlerFunc) IRoutes {
	group.Handlers = append(group.Handlers, middleware...)
	return group.returnObj()
}
```





默认的recover中间件

```go
// Default creates a hertz instance with default middlewares.
func Default(opts ...config.Option) *Hertz {
	h := New(opts...)
	h.Use(recovery.Recovery())

	return h
}

// Recovery returns a middleware that recovers from any panic.
// By default, it will print the time, content, and stack information of the error and write a 500.
// Overriding the Config configuration, you can customize the error printing logic.
func Recovery(opts ...Option) app.HandlerFunc {
	cfg := newOptions(opts...)

	return func(c context.Context, ctx *app.RequestContext) {
		defer func() {
			if err := recover(); err != nil {
				stack := stack(3)

				cfg.recoveryHandler(c, ctx, err, stack)
			}
		}()
		ctx.Next(c)
	}
}

// Next should be used only inside middleware.
// It executes the pending handlers in the chain inside the calling handler.
func (ctx *RequestContext) Next(c context.Context) {
	ctx.index++
	for ctx.index < int8(len(ctx.handlers)) {
		ctx.handlers[ctx.index](c, ctx)
		ctx.index++
	}
}
```



```go
func (engine *Engine) ServeHTTP(c context.Context, ctx *app.RequestContext) {
	if engine.PanicHandler != nil {
		defer engine.recv(ctx)
	}

	rPath := string(ctx.Request.URI().Path())
	httpMethod := bytesconv.B2s(ctx.Request.Header.Method())
	unescape := false
	if engine.options.UseRawPath {
		rPath = string(ctx.Request.URI().PathOriginal())
		unescape = engine.options.UnescapePathValues
	}

	if engine.options.RemoveExtraSlash {
		rPath = utils.CleanPath(rPath)
	}

	// Follow RFC7230#section-5.3
	if rPath == "" || rPath[0] != '/' {
		serveError(c, ctx, consts.StatusBadRequest, default400Body)
		return
	}

	// Find root of the tree for the given HTTP method
	t := engine.trees
	paramsPointer := &ctx.Params
	for i, tl := 0, len(t); i < tl; i++ {
		if t[i].method != httpMethod {
			continue
		}
		// Find route in tree
		value := t[i].find(rPath, paramsPointer, unescape)

		if value.handlers != nil {
			ctx.SetHandlers(value.handlers)
			ctx.SetFullPath(value.fullPath)
			ctx.Next(c)
			return
		}
		if httpMethod != consts.MethodConnect && rPath != "/" {
			if value.tsr && engine.options.RedirectTrailingSlash {
				redirectTrailingSlash(ctx)
				return
			}
			if engine.options.RedirectFixedPath && redirectFixedPath(ctx, t[i].root, engine.options.RedirectFixedPath) {
				return
			}
		}
		break
	}

	if engine.options.HandleMethodNotAllowed {
		for _, tree := range engine.trees {
			if tree.method == httpMethod {
				continue
			}
			if value := tree.find(rPath, paramsPointer, unescape); value.handlers != nil {
				ctx.SetHandlers(engine.allNoMethod)
				serveError(c, ctx, consts.StatusMethodNotAllowed, default405Body)
				return
			}
		}
	}
	ctx.SetHandlers(engine.allNoRoute)
	serveError(c, ctx, consts.StatusNotFound, default404Body)
}
```





# demo



中间件可以理解为洋葱穿透。

c.Next() 之前的操作是在 Handler 执行之前就执行；
c.Next() 之后的操作是在 Handler 执行之后再执行；



```go
// Code generated by hertz generator.

package main

import (
    "context"
    "fmt"
    "github.com/cloudwego/hertz/pkg/app"
    "github.com/cloudwego/hertz/pkg/app/server"
    "github.com/cloudwego/hertz/pkg/protocol/consts"
)

// customizeRegister registers customize routers.
func customizedRegister(h *server.Hertz) {
    h.Use(func(c context.Context, ctx *app.RequestContext) {
        fmt.Println("Hello Before 1")
        ctx.Next(c)
        fmt.Println("Hello After 1")
    })
    
    h.Use(func(c context.Context, ctx *app.RequestContext) {
        fmt.Println("Hello Before 2")
        ctx.Next(c)
        fmt.Println("Hello After 2")
    })
    
    h.Any("/middleware", func(c context.Context, ctx *app.RequestContext) {
        ctx.String(consts.StatusOK, "hello")
    })
    
    h.Use(func(c context.Context, ctx *app.RequestContext) {
        fmt.Println("Hello Before 3")
        ctx.Next(c)
        fmt.Println("Hello After 3")
    })
    
    h.Use(func(c context.Context, ctx *app.RequestContext) {
        fmt.Println("Hello Before 4")
        ctx.Next(c)
        fmt.Println("Hello After 4")
    })
    
}
```



输出结果：

```
Hello Before 1
Hello Before 2
to handler
Hello After 2
Hello After 1
```

