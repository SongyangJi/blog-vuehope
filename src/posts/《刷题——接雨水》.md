---
title: 《刷题——来接雨水啦》
date: 2023-01-08 21:38:07
categories: 算法题
tags:
---



# 接雨水
[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

> 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
> 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
> 输出：6
> 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 

>输入：height = [4,2,0,3,2,5]
>输出：9

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210316192431665.png)


## 按列枚举
### 暴力法
枚举每一个"凹坑"，然后向后向右找最高的柱子二者间的最小值。
二者间的较小值减去这个“坑”的高度就是存储的水。
时间复杂度$O(n^2)$

注意，这里的“水”的累加，是按竖着的方块计算的。
如下图：

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if(n<=2) return 0;
        int ans = 0;
        for(int i=1;i<n-1;i++) {
            int h1 = 0, h2 = 0;
            for(int j=i;j>=0;j--) h1 = max(h1,height[j]);
            for(int j=i;j<n;j++) h2 = max(h2,height[j]);
            ans += min(h1,h2) - height[i];
        }
        return ans;
    }
};
```

### 前缀（后缀）最大
类似于前缀和的思想，预处理一下。
时间复杂度:$O(n)$
```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0,n = height.size();
        if(n<=2) return 0;
        vector<int> lm(n),rm(n);
        for(int i=0;i<n;i++){
            if(i == 0) lm[i] = height[i];
            else lm[i] = max(lm[i-1],height[i]);
        }
        for(int i=n-1;i>=0;i--){
            if(i == n-1) rm[i] = height[i];
            else rm[i] = max(rm[i+1],height[i]);
        }
        for(int i=1;i<n-1;i++){
            ans += min(lm[i],rm[i])-height[i];
        }
        return ans;
    }
};
```


### 双指针
上面是从左向右遍历来累加水柱。
如果考虑从左右两边来遍历的话，就可以这样解决。
记 leftmax, rightmax 分别为从左到右遍历、从右到左遍历的最大值，
而left、right 分别是从左到右、从右到左的指针，

**这个时候 ，left的水柱对答案对贡献的为  $min(leftmax,rightmax)$;
但是此时leftmax的值已经求出，但是rightmax的值尚未求出，所以，如果此时leftmax小于等于rightmax的话，left的水柱对答案的贡献就知道了，然后更新leftmax，left右移。
反之亦然。**


```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        int lmax = 0, rmax = 0;
        int n = height.size(), l = 0, r = n - 1;
        while (l <= r) {
            if (lmax > rmax) {
                ans += max(rmax - height[r], 0);
                rmax = max(rmax, height[r--]);
            } else {
                ans += max(lmax - height[l], 0);
                lmax = max(lmax, height[l++]);
            }
        }
        return ans;
    }
};
```

## 按行枚举
换一种分割思路，将“水”按行进行划分。如下图：


### 暴力法
时间复杂度：$O(maxH*n)$
```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0,n = height.size();
        if(n<=2) return 0;
        int maxH = *max_element(height.begin(),height.end());
        for(int h = 0; h < maxH ; h++){
            vector<int> v;
            for(int i=0;i<n;i++){
                if(height[i]>h){
                    v.push_back(i);
                }
            }
            for(int i=1;i<v.size();i++){
                ans += v[i] - v[i-1] -1;
            }
        }
        return ans;
    }
};
```



### 单调栈
时间复杂度：$O(n)$
```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        int n = height.size();
        stack<int> st;
        for(int i=0;i<n;i++){
            while(!st.empty() && height[i] > height[st.top()]){
                int h = height[st.top()];
                st.pop();
                if(!st.empty()){
                    ans += ( min(height[i],height[st.top()]) - h)*(i - st.top() - 1);
                }
            }   
            st.push(i);   
        }
        return ans;
    }
};
```



# 接雨水II

[407. 接雨水 II](https://leetcode.cn/problems/trapping-rain-water-ii/)

[题解](https://leetcode.cn/problems/trapping-rain-water-ii/solutions/1079738/jie-yu-shui-ii-by-leetcode-solution-vlj3/)

一圈一圈地拓展最外层：每次用最矮的柱子去拓展。

形象地说，根据木桶原理，装水的多少由最短的木板决定，而现在就是不断地加厚桶壁！

```cpp
const int N = 210;
const int dx[] = {0, 1, 0, -1};
const int dy[] = {1, 0, -1, 0};
class Solution {
public:
    struct Node{
        int h, x, y;
        bool operator<(const Node& node) const {
            return h > node.h;
        }
    };

    int trapRainWater(vector<vector<int>>& g) {
        int m = g.size(), n = g[0].size();
        if (m < 3 || n < 3) return 0;
        priority_queue<Node> pq;
        bool vis[N][N]{};
        int ans = 0;
        // 将最外围的边框入小根堆
        for (int j = 0; j < n; j++) {
            pq.push({g[0][j],0, j});
            pq.push({g[m - 1][j], m - 1, j});
            vis[0][j] = vis[m - 1][j] = 1;
        }
        for (int i = 1; i < m - 1; i++) {
            pq.push({g[i][0], i, 0});
            pq.push({g[i][n-1], i, n - 1});
            vis[i][0] = vis[i][n - 1] = 1;
        }

        while (!pq.empty()) {
            Node node = pq.top();
            pq.pop();
            int h = node.h;
            int x = node.x;
            int y = node.y;
            for (int k = 0; k < 4; k++) {
                int nx = x + dx[k];
                int ny = y + dy[k];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && !vis[nx][ny]) {
                    ans += max(0, h - g[nx][ny]);
                    pq.push({max(h, g[nx][ny]), nx, ny});
                    vis[nx][ny] = 1;
                }
            }
        }
        return ans;
    }
};

```

