---
title: 《刷题——二叉树》
date: 2023-01-23 05:01:31
categories: 算法题
tags:
---



## 二叉树



### 二叉树的LCA（least-common-ancestor）
```java
import java.util.*;

public class Solution {

    public int lowestCommonAncestor (TreeNode root, int o1, int o2) {
        // write code here
        if(root == null) return -1;
        if(root.val == o1) return o1;
        if(root.val == o2) return o2;
        int l1 = lowestCommonAncestor(root.left, o1, o2);
        int l2 = lowestCommonAncestor(root.right, o1, o2);
        // l1、l2 不可能同时为 -1
        if(l1 == -1) return l2;
        if(l2 == -1) return l1;
        return root.val;
    }
}
```





### 二叉树的重建 + 层序遍历
```java
import java.util.*;

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 求二叉树的右视图
     * @param xianxu int整型一维数组 先序遍历
     * @param zhongxu int整型一维数组 中序遍历
     * @return int整型一维数组
     */
    static class Node {
        int val;
        Node left, right;
        Node(int val) {
            this.val = val;
        }
    }
    
    Node root;
    int[] pre, medi;
    
    Node build(int l1, int r1 ,int l2, int r2) {
        if(l1 > r1) return null;
        int rootVal = pre[l1];
        Node node = new Node(rootVal);
        int idx = -1;
        for(int i = l2; i <= r2; i++) {
            if(medi[i] == rootVal) {
                idx = i;
                break;
            }
        }
        int leftCnt = idx - l2;

        Node leftChild = build(l1 + 1, l1 + leftCnt, l2, idx - 1);
        Node rightChild = build(l1 + leftCnt + 1, r1, idx + 1, r2);
        node.left = leftChild;
        node.right = rightChild;
        return node;
    }
    
    public int[] solve (int[] pre, int[] medi) {
        // write code here
        this.pre = pre;
        this.medi = medi;
        int n = pre.length;
        
        this.root = build(0, n - 1, 0, n - 1);
        
        List<Integer> res = new ArrayList<>();
        Queue<Node> q = new LinkedList<Node>();
        q.offer(root);
        while(q.size() > 0) {
            int cnt = q.size();
            for(int i = 0; i < cnt; i++) {
                Node node = q.poll();
                if(i == 0) {
                    res.add(node.val);
                }
                if(node.right != null) q.offer(node.right);
                if(node.left != null) q.offer(node.left);
            }
        }
        return res.stream().mapToInt(Integer::valueOf).toArray();
    }
}
```



### 二叉树中的最大路径和
给定一颗二叉树，求二叉树的直径。
1.该题的直径定义为：树上任意两个节点路径长度的最大值；
2.该题路径长度定义为：不需要从根节点开始，也不需要在叶子节点结束，也不需要必须从父节点到子节点，一个节点到底另外一个节点走的边的数目；
3.这个路径可能穿过根节点，也可能不穿过；
4.树为空时，返回 0；

思路类似于**树形DP**求直径。



```java
import java.util.*;

public class Solution {
    
    int ans = -(int)1e8;
    public int maxPathSum (TreeNode root) {
        // write code here
        dfs(root);
        return ans;
    }
    
    int dfs(TreeNode root) { // return 从这个节点（此节点的值必选）出发的”链“的最大和
        if(root == null) return 0;
        int lv = dfs(root.left);
        int rv = dfs(root.right);
        ans = Math.max(ans, (lv > 0 ? lv : 0) + (rv > 0 ? rv : 0) + root.val); // 串上左右节点
        int cs = Math.max(lv, rv) > 0 ? Math.max(lv, rv) : 0; // 向左出发、向右出发
        return cs + root.val; // 本身的节点的值必选
    }
}
```