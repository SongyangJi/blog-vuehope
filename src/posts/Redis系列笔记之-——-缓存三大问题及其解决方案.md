---
title: Redis系列笔记之 —— 缓存三大问题及其解决方案
date: 2021-10-31
categories: Redis
tags:
  - NoSQL
  - Redis
---



> 老八股文了，redis必问问题。


# 缓存的利与弊

## 引入缓存的优点

+ 能够缩短服务的响应时间，给用户带来更好的体验。
+ 能够增大系统的吞吐量，依然能够提升用户体验。
+ 减轻数据库的压力，防止高峰期数据库被压垮，导致整个线上服务 BOOM！

##  引入缓存的缺点

+ 缓存有多种选型，是内存缓存，memcached 还是 redis，你是否都熟悉，如果不熟悉，无疑增加了维护的难度（本来是个纯洁的数据库系统）。
+ 缓存系统也要考虑分布式，比如 redis 的分布式缓存还会有很多坑，无疑增加了系统的复杂性。
+ 在特殊场景下，如果对缓存的准确性有非常高的要求，就必须考虑缓存和数据库的一致性问题。



适合缓存的数据：读多写少、不常变化的数据，比如详情，评论等。

不适合缓存的数据：对于那些经常变化的数据，其实并不适合缓存，一方面会增加系统的复杂性（缓存的更新，缓存脏数据），另一方面也给系统带来一定的不稳定性（缓存系统的维护）。



但一些极端情况下，你需要将一些会变动的数据进行缓存，比如想要页面显示准实时的库存数，或者其他一些特殊业务场景。这时候你需要保证缓存不能（一直）有脏数据，这就需要再深入讨论一下，也就是**缓存-数据库一致性的问题**。





# 缓存穿透

## 问题描述

缓存穿透是指**缓存和数据库中都没有的数据**，而用户不断发起请求，如发起id为-1的数据或者特别大的不存在的数据。有可能是黑客利用漏洞攻击从而去压垮应用的数据库。



## 解决方案

对于缓存穿透问题，常见的解决方案有以下三种：

1. **验证拦截**：接口层进行校验，如鉴定用户权限，对ID之类的字段做基础的校验，如`id<=0`的字段直接拦截；
2. **缓存空数据**：当数据库查询到的数据为空时，也将这条数据进行缓存，但缓存的有效性设置得要较短，以免影响正常数据的缓存（因为有可能一开始没有这个key，但后来有了，当然你可以主动删除缓存）；
3. 使用布隆过滤器：布隆过滤器是一种比较独特数据结构，有一定的误差。当它指定一个数据存在时，它可能存在也可能不存在，但是当它指定一个数据不存在时，那么它一定是不存在的。（~~具体使用方法参考文章模链接~~）





# 缓存击穿

## 问题描述

缓存击穿是指当前热点数据存储到期时，**多个线程同时并发访问热点数据**。因为缓存刚过期，**所有并发请求都会到数据库中查询数据**。



## 解决方案

+ 将热点数据设置为永不过期；

+ 加互斥锁：互斥锁可以控制查询数据库的线程访问，只让一个请求通过，只有一个请求去数据库拉取数据，取完数据，不管如何都需要释放锁。

+ 添加超时标记：在缓存的对象上增加一个属性来标识超时时间，当获取到数据后，校验数据内部的标记时间，判定是否快超时了，如果是，异步发起一个线程（控制好并发）去主动更新该缓存。




```java
public String get(Object key, int retryCount) {
    // 重试次数太多直接 return null
    if(retryCount > 5) {
        return null;
    }
    String value = redis.get(key);
    if (value == null) { // 代表缓存值过期
        // 设置1 min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
        if (redis.setnx(key_mutex, 1, 60) == 1) {  // 代表设置成功
            try {
                value = db.get(key);
                redis.set(key, value, expire_secs);
            } finally {
                // 确保最后删除，释放锁
                redis.del(key_mutex); 
            }
        } else {
            // 这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
            sleep(200);
            get(key, retryCount + 1);  // 重试
        }
    } else {
        return value;
    }
}
```





# 缓存雪崩

## 问题描述

缓存雪崩是指缓存中有大量的数据，在同一个时间点，或者较短的时间段内，全部过期了，这个时候请求过来，缓存没有数据，都会请求数据库，则数据库的压力就会突增，扛不住就会宕机。

造成缓存雪崩的关键在于在同一时间大规模的key失效。为什么会出现这个问题呢，有几种可能，

第一种可能是Redis宕机，

第二种可能是采用了相同的过期时间。




## 解决方案



1. 如果是热点数据，那么可以考虑**设置永远不过期**。
2. 缓存的过期时间除非比较严格，要不考虑**设置一个波动随机值**，比如理论十分钟，那这类key的缓存时间都加上一个1-3分钟，过期时间在7-13分钟内波动，**有效防止都在同一个时间点上大量过期**。
3. 如果所有的热点数据在一台redis服务器上，也是极其危险的，如果网络有问题，或者redis服务器挂了，那么所有的热点数据也会雪崩（查询不到），因此**将热点数据打散分不到不同的机器上**，也可以有效减少这种情况。
5. 对于redis服务挂掉的问题,可以实现redis的高可用主从架构, 并且做redis的持久化, 在redis挂掉的同时时读取本地缓存数据, 同时恢复redis服务加载持久化的数据。



+ 【事前】**高可用缓存**：高可用缓存是防止出现整个缓存故障。即使个别节点，机器甚至机房都关闭，系统仍然可以提供服务，Redis 哨兵(Sentinel) 和 Redis 集群(Cluster) 都可以做到高可用；
+ 【事中】**缓存降级**（临时支持）：当访问次数急剧增加导致服务出现问题时，我们如何确保服务仍然可用。在国内使用比较多的是 Hystrix，它通过熔断、降级、限流三个手段来降低雪崩发生后的损失。只要确保数据库不死，系统总可以响应请求，每年的春节 12306 我们不都是这么过来的吗？只要还可以响应起码还有抢到票的机会；
+ 【事后】**备份和快速预热**：Redis数据备份和恢复、快速缓存预热。



> 参考链接：
>
> [Guava布隆过滤器(boomfilter)使用简介](https://blog.csdn.net/Revivedsun/article/details/94992323)

