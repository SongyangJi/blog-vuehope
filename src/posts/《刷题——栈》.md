---
title: 《刷题——栈、队列》
date: 2022-12-31 19:32:45
categories: 算法题
tags:
---





## 栈



### 双栈队列

```java
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>(); // 正常的栈
    Stack<Integer> stack2 = new Stack<Integer>(); // FIFO的顺序
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
        if(stack2.size() > 0) return stack2.pop();
        // 空的话，就一口气全将 “正常的栈” 弹出来
        while(!stack1.isEmpty()) {
            stack2.push(stack1.pop());
        }
        return stack2.pop();
    }
}
```



### 包含min函数的栈（单调栈）



```java
import java.util.Stack;

public class Solution {

    Stack<Integer> st = new Stack<>(), minSt = new Stack<>(); // 单调递减
    public void push(int node) {
       st.push(node);
       if(minSt.isEmpty() || node <= minSt.peek()) { // notice <= 
           minSt.push(node);
       }
     }
    
    public void pop() {
        int x = st.pop();
        if(x == minSt.peek()) {
            minSt.pop();
        }
    }
    
    public int top() {
        return st.peek();
    }
    
    public int min() {
        return minSt.peek();
    }
}
```


### 表达式计算问题

最一般性的做法：

**单调栈**的思想

```java
import java.util.*;

/**
 * 本解法并未解决单元运算符 + - 的问题。
 * 细节
 * 1. 空格事先过滤
 * 2. 遇到整数一次性处理出来
 * 3. 注意先出栈的是第二个运算数，然后才是第一个运算数
 * 4. 遇到 '(' 直接入操作符栈； 遇到')' ，要一直算到 '('
 * 尤其是第4点；
 * 本题的核心思想，运算符栈实际上是一个单调栈，栈内的运算符优先级严格递增，
 * 也就是说，[+,*]:[2,3,4]是合法的，它表示 2 + 3 * 4；
 * [*,+]:[2,3,4]是不可以的，它实际上是2*3+4，但却被处理成 2*(3+4)
 * 
 */
public class Solution {

    static class Opt {
        char c;
        int priority;

        public Opt(char c) {
            this.c = c;
            int p = -1; // '(' 为 -1
            switch (c) {
                case '+':
                case '-':
                    p = 1;
                    break;
                case '*':
                    p = 2;
                    break;
            }
            this.priority = p;
        }

        public boolean isHigh(Opt o) {
            return this.priority > o.priority;
        }
    }

    void handle(Opt opt) {
        // 注意先出栈的是第二个运算数
        int x2 = nums.pop();
        int x1 = nums.pop();
        switch (opt.c) {
            case '*':
                nums.push(x1 * x2);
                break;
            case '+':
                nums.push(x1 + x2);
                break;
            case '-':
                nums.push(x1 - x2);
                break;
            default:
                break;
        }
    }

    Stack<Opt> ops = new Stack<>();
    Stack<Integer> nums = new Stack<>();

    public int solve(String s) {

        s = s.replaceAll(" ",""); // 预处理

        // write code here
        char[] cs = s.toCharArray();
        int n = cs.length;

        for (int i = 0; i < n;) {
            if (Character.isDigit(cs[i])) {
                StringBuilder number = new StringBuilder();
                while (i < n && Character.isDigit(cs[i])) {
                    number.append(cs[i++]);
                }
                int val = Integer.parseInt(number.toString());
                nums.push(val);
            } else {
                if (cs[i] == '(') {
                    ops.push(new Opt(cs[i]));
                } else if (cs[i] == ')') {
                    while (!ops.isEmpty()) {
                        Opt opt = ops.pop();
                        if (opt.c == '(') break;
                        handle(opt);
                    }
                } else {
                    Opt opt = new Opt(cs[i]);
                    while (!ops.isEmpty() && !opt.isHigh(ops.peek())) { // 运算符保持递增
                        handle(ops.pop());
                    }
                    ops.push(opt);
                }
                i++;
            }
        }
        while (!ops.isEmpty()) {
            handle(ops.pop());
        }
        return nums.pop();
    }
    
}
```





### 字符串解码

[394. 字符串解码](https://leetcode.cn/problems/decode-string/description/)

```c++
class Solution {
public:
    string decodeString(string s) {
        stack<int> ns;
        vector<string> ss;
        int i = 0;
        int len = s.size();
        while (i < len) {
            if (s[i] <= '9' && s[i] >= '0') {
                int n = 0;
                while (i < len && s[i] <= '9' && s[i] >= '0') {
                    n = n * 10 + s[i++] - '0';
                }
                ns.push(n);
            } else if (s[i] == '[') {
                ss.push_back("[");
                ++i;
            } else if (s[i] == ']') {
                string res;
                string tmp;
                int idx = ss.size() - 1;
                while(idx >= 0 && ss[idx] != "[") {
                    --idx;
                }
                for (int j = idx + 1; j < ss.size(); ++j) {
                    tmp += ss[j];
                }
                while (ss.back() != "[") ss.pop_back();
                ss.pop_back();
                int count = ns.top();
                ns.pop();
                while (count--) {
                    res += tmp;
                }
                ss.push_back(res);
                ++i;
            } else {
                string tmp;
                tmp += s[i++];
                ss.push_back(tmp);
            }
        }
        string ans;
        for (string &tmp: ss) { 
            ans += tmp;
        }
        return ans;
    }
};
```



### 最长有效括号（栈）

[32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

给出一个长度为 n 的，仅包含字符 '(' 和 ')' 的字符串，计算最长的格式正确的括号子串的长度。
例1: 对于字符串 "(()" 来说，最长的格式正确的子串是 "()" ，长度为 2 .
例2：对于字符串 ")()())" , 来说, 最长的格式正确的子串是 "()()" ，长度为 4 .

字符串长度：0 < n < 5*10^5

要求时间复杂度 O(n),空间复杂度 O(n).



**栈**
始终保持**栈底元素**为当前已经遍历过的元素中**最后一个没有被匹配的右括号**的下标，
栈里其他元素维护左括号的下标。

```java
import java.util.*;
public class Solution {
    public int longestValidParentheses (String s) {
        // write code here
        int ans = 0;
        Deque<Integer> dq = new ArrayDeque<>();
        dq.offer(-1);
        for(int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if(c == '(') {
                dq.offer(i);
            } else {
                if(dq.size() == 1) {
                    dq.pollLast();
                    dq.offer(i);
                } else {
                    dq.pollLast();
                    ans = Math.max(ans, i - dq.peekLast());
                }
            }
        }
        return ans;
    }
}
```



这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，**但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的**。

解决的方法也很简单，我们只需要从右往左遍历用类似的方法计算即可，只是这个时候判断条件反了过来。

```java
class Solution {
public:
    int longestValidParentheses(string s) {
        int left = 0, right = 0, maxlength = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '(') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                maxlength = max(maxlength, 2 * right);
            } else if (right > left) {
                left = right = 0;
            }
        }
        left = right = 0;
        for (int i = (int)s.length() - 1; i >= 0; i--) {
            if (s[i] == '(') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                maxlength = max(maxlength, 2 * left);
            } else if (left > right) {
                left = right = 0;
            }
        }
        return maxlength;
    }
};
```



## 队列

### 滑动窗口的最大值 (单调队列)

给你一个数组，给你一个大小为size的窗口，窗口在移动，求窗口在移动过程中的最大值序列。

```java
import java.util.*;
public class Solution {
    public ArrayList<Integer> maxInWindows(int [] num, int size) {
        ArrayList<Integer> ans = new ArrayList<Integer>();
        int n = num.length;
        if(size > n  || size == 0) return ans; // 单调不升
        Deque<Integer> q = new ArrayDeque<>();
        for(int i = 0; i < n; i++) {
            if(i >= size && q.peekFirst() == num[i - size]) {
                q.pollFirst();
            }
            while(q.size() > 0 && q.peekLast() < num[i]) { 
            // 直到 last >= cur
                q.pollLast();
            }
            q.offerLast(num[i]);
            if(i >= size - 1) {
                ans.add(q.peekFirst()); // 队首最大
            }            
        }
        return ans;
    }
}
```

