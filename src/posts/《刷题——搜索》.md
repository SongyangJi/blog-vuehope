---
title: 《刷题——搜索》
date: 2023-01-23 06:20:15
categories: 算法题
tags:
---



## 递归、深搜

### 字符串的全排列

**有重复字符如何去重？**

```java
import java.util.*;

public class Solution {
    Set<String> res = new HashSet<>();
    char[] cs;
    boolean[] st;
    int n;
    String str;
    
    public ArrayList<String> Permutation(String str) {
        n = str.length();
        cs = new char[n];
        st = new boolean[n];
        this.str = str;
        dfs(0);
        return new ArrayList<>(res);
    }
    
    void dfs(int pos) {
        if(pos == n) {
            res.add(new String(cs));
            return;
        }
        for(int i = 0; i < n; i++) {
            if(!st[i]) {
                st[i] = true;
                cs[pos] = str.charAt(i);
                dfs(pos+1);
                st[i] = false;
            }
        }
    }
    
}
```



直接去重

```java
import java.util.*;

public class Solution {
    
    int n;
    String str;
    StringBuilder sb = new StringBuilder();
    boolean[] used = new boolean[15];
    
    ArrayList<String> ans = new ArrayList<>();
    
    public ArrayList<String> Permutation(String str) {
        n = str.length();
        char[] cs = str.toCharArray();
        Arrays.sort(cs);
        this.str = new String(cs);
        dfs(0);
        return ans;
    }
    
    void dfs(int pos) {
        if(pos == n) {
            ans.add(sb.toString());
            return;
        }
        int old = -1;
        for(int i = 0; i < n; i++) {
            if(!used[i]) {
                if(old >= 0 && str.charAt(i) == str.charAt(old) ) {  // key code
                    continue;
                }
                used[i] = true;
                old = i;
                sb.append(str.charAt(i));
                dfs(pos + 1);
                used[i] = false;
                sb.deleteCharAt(sb.length() - 1);
            }
        }
    }
}
```





### 括号生成
```java
import java.util.*;

public class Solution {
    ArrayList<String> ans = new ArrayList<>();
    int n;
    public ArrayList<String> generateParenthesis (int n) {
        // write code here
        this.n = n;
        dfs(0, 0, "");
        return ans;
    }
    
    void dfs(int ls, int rs, String s) {
        // 左括号可以一直放，右括号数比左括号数小的时候，才能放右括号（本身就是剪枝了）
        if(ls == n && rs == n) {
            ans.add(s);
            return;
        }
        if(ls < n) {
            dfs(ls + 1, rs, s + "(");
        }
        
        if(ls > rs) {
            dfs(ls, rs + 1, s + ")");
        }
    }
    
}
```



### IP生成（dfs+剪枝）
现在有一个只包含数字的字符串，将该字符串转化成IP地址的形式，返回所有可能的情况。

例如：
给出的字符串为"25525522135",
返回["255.255.22.135", "255.255.221.35"]. (顺序没有关系)

数据范围：字符串长度 0 < n < 12
```java
import java.util.*;

public class Solution {
    ArrayList<String> ans = new ArrayList<>();
    int n;
    char[] s;
    public ArrayList<String> restoreIpAddresses (String s) {
        // write code here
        n = s.length();
        this.s = s.toCharArray();
        dfs(0, "", "", 0);
        return ans;
    }
    
    void dfs(int pos, String res, String last, int cnt) { // res结果, cnt “.” 的个数，last单个
        if(cnt > 3) return; // 剪枝
        if(pos == n) {
            if(cnt == 3) ans.add(res);
            return ; // must return whatever
        }
        last = last + s[pos];
        int val = Integer.parseInt(last);
        if(val <= 255) { // 剪枝
            // 有两种选择， 要么加"."，要么不加"."
            // 除非是最后一位，否则需要满足 (val > 0 && val <= 25)
            if(pos + 1 == n || (val > 0 && val <= 25))  dfs(pos + 1, res + s[pos], last, cnt);
            if(pos + 1 != n) dfs(pos + 1, res + s[pos] + '.', "", cnt + 1); // 最后一位不能加 '.'
        }
    }
    
}
```

--上面的解法没有考虑到前导零--


```cpp
class Solution {
public:
    vector<string> ans;

    vector<string> restoreIpAddresses(string s) {
        dfs(s, 0, 0, "");
        return ans;
    }

    void dfs(const string &s, int idx, int cnt, string res) {
        if (cnt == 4) {
            if (idx == s.size()) {
                ans.push_back(res);
            }
            return; // 必return
        }
        for (int k = 1; k <= 3; k++) {
            if (idx + k > s.size()) break;
            string number = s.substr(idx, k); // substr(start_iter, sublen)
            int num = stoi(number);
            if ((k == 1) || (k == 2 && num >= 10) || (k == 3 && num >= 100 && num <= 255)) { // 防止前导零
                if (cnt) dfs(s, idx + k, cnt + 1, res + "." + number);
                else dfs(s, idx + k, cnt + 1, res + number);
            }
        }
    }
};
```



### 子集

```java
import java.util.*;

public class Solution {
    ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();
    ArrayList<Integer> list = new ArrayList<>();
    int n;
    int[] a;
    public ArrayList<ArrayList<Integer>> subsets(int[] a) {
        this.n = a.length;
        this.a = a;
        Arrays.sort(a);
        dfs(0);
        return ans;
    }

    void dfs(int pos) {
        if(pos == n) {
            ans.add(new ArrayList<>(list));
            return ;
        }
        list.add(a[pos]);
        dfs(pos + 1);
        list.remove(list.size() - 1);
        dfs(pos+1);
    }
}
```



一种复制的思想：

```java
import java.util.*;

public class Solution {
    public ArrayList<ArrayList<Integer>> subsets(int[] S) {
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        ans.add(new ArrayList<>());
        for (int i = 0; i < S.length; i++) {
            ArrayList<ArrayList<Integer>> res = new ArrayList<>();
            for (ArrayList<Integer> temp : ans) {
                ArrayList<Integer> list = new ArrayList<>(temp);
                list.add(S[i]);
                res.add(list);
            }
            ans.addAll(res);
        }
        return ans;
    }
}
```



状态压缩的思想
```java
import java.util.*;

public class Solution {
    public ArrayList<ArrayList<Integer>> subsets(int[] S) {
        ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();
        Arrays.sort(S);
        int n = S.length;
        for(int s = 0; s < (1<<n); s++) {
            ArrayList<Integer> list = new ArrayList<>();
            int st = s;
            int idx = 0;
            while(st > 0) {
                if((st&1) > 0) {
                    list.add(S[idx]);
                }
                idx++;
                st >>= 1;
            }
            ans.add(list);
        }
        return ans;
    }
}
```



### 全排列的交换写法
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    vector<vector<int> > permute(vector<int> &num) {
        vector<vector<int> > res;
        dfs(res, num, 0);
        return res;
    }

    void dfs(vector<vector<int> > &res, vector<int> &num, int idx) {
        if (idx == num.size() - 1) { res.push_back(num); return; }
        for (int i = idx; i < num.size(); ++i) {
            swap(num[i], num[idx]);
            dfs(res, num, idx + 1);
            swap(num[i], num[idx]); // 回溯
        }
    }
};
```





### 全排列（字典序+去重）

给出一组可能包含重复项的数字，返回该组数字的所有排列。结果以字典序升序排列。
数据范围： 0 < n < 8，数组中的值满足 -1 < val < 5;
要求：空间复杂度 O(n!)，时间复杂度 O(n!)

```java
import java.util.*;

public class Solution {
    ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();
    int[] temp, num;
    int n;
    boolean[] used;
    public ArrayList<ArrayList<Integer>> permuteUnique(int[] num) {
        this.n = num.length;
        used = new boolean[n];
        // 排序是为了 去重+字典序 
        Arrays.sort(num);
        this.num = num;
        this.temp = new int[n];
        dfs(0);
        return ans;
    }

    void dfs(int pos) {
        if(pos == n) {
            ArrayList<Integer> list = new ArrayList<>();
            for (int i : temp) {
                list.add(i);
            }
            ans.add(list);
            return;
        }
        int old = -2;
        for(int i = 0 ; i < n; i++) {
            if(!used[i] && (old == -2 || old != num[i])) { // 去重
                used[i] = true;
                old = num[i];
                temp[pos] = num[i];
                dfs(pos + 1);
                used[i] = false;
            }
        }
    }

}
```


### 组合数（字典序、去重）

**给出一组候选数 c 和一个目标数 t ，找出候选数中起来和等于 t 的所有组合**。
c 中的每个数字在一个组合中只能使用一次。
数据范围: 1 ≤ n ≤ 70 ， 1≤target≤100 ， 1 < C_i < 50
要求：空间复杂度 O(n!) ， 时间复杂度 O(n!)

```java
import java.util.*;
public class Solution {
    ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();
    ArrayList<Integer> list = new ArrayList<>();
    int[] num;
    int target;
    int n;
    public ArrayList<ArrayList<Integer>> combinationSum2(int[] num, int target) {
        // 字典序
        Arrays.sort(num);
        this.num = num;
        this.target = target;
        this.n = num.length;
        dfs(0, 0, true);
        return ans;
    }
    
    void dfs(int pos,int s, boolean lastUsed) {
        // 大方向还是 挑或不挑
        if(s > target) return; // 剪枝
        if(pos == n) {
            if(s == target) ans.add(new ArrayList<>(list));
            return;
        }
        // 先 dfs 选的情况（字典序的要求）
        if(lastUsed || pos == 0 || num[pos] != num[pos - 1]) { //去重， 上一次没选x，这一次就不能选了
            list.add(num[pos]);
            dfs(pos + 1, s + num[pos], true);
            list.remove(list.size() - 1);
        }
        dfs(pos + 1, s, false);
    }
    
}
```



一个不一样的做法，DP思路。

```java
class Solution {
public:
    vector<vector<int> > combinationSum2(vector<int> &num, int target) {
        vector<vector<int> > res;
        vector<int> tmp;
        if (num.empty()) return res;
        sort(num.begin(), num.end());//对候选素组进行排序，在一定程度上可以优化搜索
        dfs(num, target, res, tmp, 0);//开始搜索 刚开始start=0 从第一个开始搜索
        return res;//返回最后的结果
    }

    void dfs(vector<int> &num, int target, vector<vector<int> > &res, vector<int> &tmp, int start) {
        if (target == 0) {//当每一个小组的target=0的时候 说明该分组已经分好了 直接存进res中
            res.push_back(tmp);
            return;//末端终止 避免无效搜索
        }
        if (start >= num.size()) return;//当开始搜索的位置大于候选数字的时候 整个搜索结束
        for (int i = start; i < num.size(); ++i) {//从start到候选数组末尾开始搜索
            //去重处理 若相等 直接continue 避免重复搜索
            if (i > start && num[i] == num[i - 1]) continue;
            //剪枝
            //前面的排序就有意义了 这块要是剩余的num[i]的值已经大于target的大小 后面已经是无效搜索了
            if (num[i] <= target) {
                //后面是一个回溯的过程先加入tmp 后从tmp末端删除 确保可以搜索可以进行下去
                tmp.push_back(num[i]);
                //由于num[i]加入 target的大小减去num[i] 搜索开始位置往后 也就是start+1
                dfs(num, target - num[i], res, tmp, i + 1);
                tmp.pop_back();
            }
        }
    }
};
```


