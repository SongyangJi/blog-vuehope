---
title: 一些还不错的题-1
date: 2022-03-20 00:00:01
categories: 算法题
---



## 链表

### 链表中的节点每k个一组翻转
题：将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表
如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样
你不能更改节点中的值，只能更改节点本身。

```java
class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    int len(ListNode* head) {
        int cnt = 0;
        while(head) {
            ++cnt;
            head = head->next;
        }
        return cnt;
    }
    
    ListNode* reverseKGroup(ListNode* head, int k) {
        // write code here
        ListNode *dum = new ListNode(-1), *cur = dum;
        ListNode* p = head;
        while(p) {
            int l = len(p);
            if(l < k) {
                cur->next = p;
                break;
            }
            ListNode *res = nullptr, *q = p;
            // 头插
            for(int i = 0; i < k; i++) {
                auto nxt = q->next;
                q->next = res;
                res = q;
                q = nxt;
            }
            cur->next = res; // 接上
            cur = p; // cur 移动
            p = q; // p 移动
        }
        return dum->next;
    }
};
```



```java
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* dumb = new ListNode();
        dumb->next = head;
        ListNode *pre = dumb, *end = dumb;
        while (end->next != nullptr) {
            for (int i = 0; i < k && end != nullptr; ++i) {
                end = end->next;
            }
            if (end == nullptr) break;
            ListNode* nxt = end->next; // 拿到后继
            ListNode* start = pre->next; // 拿到头
            end->next = nullptr; // 断开
            pre->next = reverse(start); // 反转
            start->next = nxt; // 接上链表
            pre = end = start; // “头”变成”尾“，从这出发
        }
        return dumb->next;
    }
    
    ListNode* reverse(ListNode* head) {
        ListNode* pre = nullptr, *cur = head;
        while (cur != nullptr) {
            ListNode* nxt = cur->   next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }
};
```








### 判断链表中是否有环（快慢指针）
```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null) return false;
        ListNode slow = head, fast = head;
        while(fast != null) {
            slow = slow.next;
            fast = fast.next;
            if(fast != null) fast = fast.next;
            if(fast == slow) return true; // 检查
        }
        return false;
    }
}
```



### 环的入口
[题解](https://song-yang-ji.blog.csdn.net/article/details/108997251)
```java
public class Solution {

    public ListNode EntryNodeOfLoop(ListNode pHead) {
        if(pHead == null || pHead.next == null) return null;
        ListNode slow = pHead, fast = pHead;
        while(fast != null) {
            slow = slow.next;
            fast = fast.next;
            if(fast != null) fast = fast.next;
            if(slow == fast) {
                ListNode cur = pHead;
                // a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)
                // a == c
                while(cur != slow) {
                    cur = cur.next;
                    slow = slow.next;
                }
                return cur;
            }
        }
        return null;
    }
}
```

### 链表相交

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) return null;
        ListNode pA = headA, pB = headB;
        // a + c + b == b + c + a (c是公共部分)
        while (pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
}
```



### 链表的两路归并

```java
public class Solution {
    public ListNode Merge(ListNode list1, ListNode list2) {
        ListNode dum = new ListNode(-1), cur = dum;
        ListNode p1 = list1, p2 = list2;
        while(p1 != null && p2 != null) {
            if(p1.val < p2.val) {
                cur.next = p1;
                p1 = p1.next;
            } else {
                cur.next = p2;
                p2 = p2.next;
            }
            cur = cur.next;
        }
        cur.next = p1 != null ? p1 : p2;
        return dum.next;
    }
}
```





### 多路归并问题

[23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

+  堆
**k路归并问题**
时间复杂度:$O(kn*log(k))$


```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
private:
    struct Node {
        ListNode* p;
        Node(ListNode*p):p(p){}
        bool operator<(const Node& b) const{
            return p->val>b.p->val;
        } 
    };
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode* preHead = new ListNode; //哨兵
        ListNode* pre = preHead;
        priority_queue<Node> pq;
        for(int i=0;i<lists.size();i++){
            if(lists[i]) pq.push(Node(lists[i]));
        }
        while(pq.size()){
            Node node = pq.top();
            pq.pop();
            pre->next = node.p;
            pre = pre->next; // 尾插
            if(node.p->next){
                pq.push(Node(node.p->next));
            }
        }
        return preHead->next;
    }
};
```

+ 分治算法
如果两两合并的话，时间复杂度 $O(k^2*n)$


分治的话：一次合并区间的一半。就像是**归并排序**一样。
时间复杂度：$O(k*log(k)*n)$

```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return devide_conquer(lists,0,(int)lists.size()-1);
    }

    ListNode* devide_conquer(vector<ListNode*>& lists,int l,int r){
        if(l==r) return lists[l];
        if(l>r) return nullptr;
        int mid = l + (r - l)/2;
        // 和归并排序一样的做法,先处理一半，再合并到一起
        ListNode* left = devide_conquer(lists, l, mid)
        ListNode* right = devide_conquer(lists, mid + 1, r);
        return mergeTwoLists(left,right);
    }

    // 双链合并的标准写法写法 
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* preHead = new ListNode; // 哨兵
        ListNode* pre = preHead;  // 移动的哨兵
        while(l1 && l2){
            if(l1->val<l2->val){
                pre->next = l1;
                l1 = l1->next;
            }else{
                pre->next = l2;
                l2 = l2->next;
            }
            pre = pre->next;
        }
        pre->next = (l1 ? l1 : l2);
        return preHead->next;
    }
};
```


**多路归并**
```java
import java.util.*;

public class Solution {
    public ListNode mergeKLists(ArrayList<ListNode> lists) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>((o1, o2) -> o1.val - o2.val);
        for(ListNode node : lists) {
            if(node != null) pq.offer(node);
        }
        ListNode dum = new ListNode(-1), cur = dum;
        while(pq.size() > 0) {
            ListNode node = pq.poll();
            cur.next = node;
            cur = node;
            if(node.next != null) {
               pq.offer(node.next);
            }
        }
        return dum.next;
    }
}
```

### 链表题

给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。

注意是节点的编号而非节点的数值。
数据范围：节点数量满足 0 < n < $10^5$，节点中的值都满足 0 < val < 10000
要求：空间复杂度 O(n)，时间复杂度 O(n)

```java
import java.util.*;

public class Solution {

    public ListNode oddEvenList (ListNode head) {
        // write code here
        ListNode l1 = new ListNode(-1), cur1 = l1;
        ListNode l2 = new ListNode(-1), cur2 = l2;
        
        ListNode p = head;
        int idx = 0;
        while(p != null) {
            ListNode q = p.next;
            p.next = null; // 孤立这个节点，否则后面会循环链接导致死循环
            if(idx % 2 == 0) {
                cur1.next = p;
                cur1 = p;
            } else {
                cur2.next = p;
                cur2 = p;
            }
            p = q;
            ++idx;
        }
        cur1.next = l2.next; // 两条链合并
        return l1.next;
    }
}
```



## 快排

### 裸快排
```java
import java.util.*;

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 将给定数组排序
     * @param arr int整型一维数组 待排序的数组
     * @return int整型一维数组
     */
    public int[] MySort (int[] arr) {
        // write code here
        qsort(arr, 0 , arr.length - 1);
        return arr;
    }
    
    void qsort(int[] a, int l, int r) {
        if(l >= r) return;
        int i = l - 1, j = r + 1, x = a[(l + r)/2];
        while(i < j) {
            do {++i;} while(a[i] < x); // 每次必移动 不等号
            do {--j;} while(a[j] > x);
            // 移动结束 a[j] <= x
            if(i < j) {
                int temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
        // j 是临界点
        qsort(a, l, j); // 都小于等于 注意 base a[j] <= x
        qsort(a, j + 1, r); // 都大于 base
    }
    
}
```



### 前K大
```java
import java.util.*;

public class Solution {
    ArrayList<Integer> ans = new ArrayList<>();
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        help(input, 0, input.length - 1, k);
        return ans;
    }
    
    void help(int[] a,int l, int r, int k) {
        if(l > r || k <= 0) return; // 终点
        int i  = l - 1, j = r + 1, x = a[(l + r)/2];
        while(i < j) {
            do {i++;} while(a[i] < x);
            do {j--;} while(a[j] > x);
            if(i < j) {
                int t = a[i]; a[i] = a[j]; a[j] = t;
            }
        }
        
        int idx = j;
        int cnt = 0;
        if(k >= idx - l + 1) { // 注意带 = 号
            for(int m = l; m <= idx; m++) {
                cnt++;
                ans.add(a[m]);
            }
            help(a, j + 1, r, k - cnt);
        } else {
            help(a, l, j, k); // 继续在前面筛选
        }
    }
    
}
```



### 第 K 大
```java
import java.util.*;

public class Solution {
    public int findKth(int[] a, int n, int K) {
        // write code here
        return help(a, 0, n - 1, n - K + 1); // 第 K 大 对应 n - K + 1
    }

    int help(int[] a, int l, int r, int K) {
        if (l >= r) return a[l];
        int i = l - 1, j = r + 1, x = a[(l + r) / 2];
        while (i < j) {
            do {
                ++i;
            } while (a[i] < x);
            do {
                --j;
            } while (a[j] > x);
            if (i < j) {
                int t = a[i];
                a[i] = a[j];
                a[j] = t;
            }
        }
        int cnt = (j - l + 1);
        // O(n) notice: K <= cnt
        return K <= cnt ? help(a, l, j, K) : help(a, j + 1, r, K - cnt);
    }
}
```

[排序链表 (归并排序、自顶而下、自底而上)](https://song-yang-ji.blog.csdn.net/article/details/109953484)


### 链表快排

**链表快排**
NC70 单链表的排序
```java
class Solution {


    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode l1 = null;    
        ListNode l2 = null;
        ListNode p = head;

        int x = head.val, y = head.val;
        while(p != null) {
            x = Math.min(x, p.val);
            y = Math.max(y, p.val);
            p = p.next;
        }
        if(x == y) return head;

        double base = (x+y)/2.0;

        // 链表的partition其实更简单一点
        // 这里使用头插法即可
        p = head;
        while(p != null) {
            ListNode q = p.next;
            if(p.val <= base) {
                p.next = l1;
                l1 = p;
            } else {
                p.next = l2;
                l2 = p;
            }
            p = q;
        }
        // 两条链表至少有一个元素，最好情况是各分一半
        l1 = sortList(l1); // l1的尾巴是 null
        l2 = sortList(l2); // l2的尾巴是 null
        // 两条链表接起来（如果是数组的话，无需这一步）
        p = l1;
        ListNode tail1 = p;
        while(p != null) {
            tail1 = p;
            p = p.next;
        }
        tail1.next = l2;
        return l1;
    }

}
```


**归并排序**
```java
import java.util.*;

public class Solution {
    /**
     * 
     * @param head ListNode类 the head node
     * @return ListNode类
     */
    public ListNode sortInList (ListNode head) {
        // write code here
        if(head == null || head.next == null) return head; // 终点
        // 快慢指针找到中点
        ListNode slow = head, fast = head, preMid = null;
        while(fast != null) {
            preMid = slow;
            slow = slow.next;
            fast = fast.next;
            if(fast != null) fast = fast.next;
        }
        preMid.next = null; // 从中间断开来
        return merge(sortInList(head),sortInList(slow));
    }
    // 两条链表的合并
    ListNode merge(ListNode l1, ListNode l2) {
        ListNode dum = new ListNode(-1), cur = dum;
        while(l1 != null && l2 != null) {
            if(l1.val < l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next; // notice
        }
        cur.next = l1 != null ? l1 : l2;
        return dum.next;
    }
}
```





## LRU

### 双向链表 + 哈希表
应该这样思考，比较合理。
**使用双向链表去维护键值对的使用顺序，也就是将刚刚使用的键值对放在链表的头部**。
但是，这样的单次操作复杂度是$O(n)$的。
如何优化，使用HashMap即可，
具体来说就是**将键与链表的节点一一对应**，这样就可以做到O(1)时间复杂度快速检索到关键节点。

```java
class LRUCache {

    private int size;
    private int capacity;
  
    // 哨兵(哑结点，不存储任何有效值)
    private Node head, tail;

    private HashMap<Integer, Node> map;

    private static class Node {
        Node prev, next; // 双向
        int key, val;

        public Node(int key,int val) {
            this.key = key;
            this.val = val;
        }

        public Node() {
        }
    }

    // 删除某个节点
    private void removeNode(Node node) {
        Node p1 = node.prev;
        Node p2 = node.next;
        p1.next = p2;
        p2.prev = p1;
    }

    // moveToHead 的辅助函数
    private void addToHead(Node node) {
        Node headNext = head.next;
        head.next = node;
        node.prev = head;
        node.next = headNext;
        headNext.prev = node;
    }

		// 将一个已有的节点移动到头部
    private void moveToHead(Node node) {
        removeNode(node);
        addToHead(node);
    }

    public LRUCache(int capacity) {
        this.capacity = capacity;
        head = new Node(); // 哑结点的构造
        tail = new Node();
        head.next = tail;
        tail.prev = head;
        map = new HashMap<>();
    }

    public int get(int key) {
        if (!map.containsKey(key)) return -1;
        Node node = map.get(key);
        moveToHead(node); // 移动到头
        return node.val;
    }

    public void put(int key, int value) {
        Node node = map.get(key);
        if (node == null) {
            if (size >= capacity) {
                Node last = tail.prev; // 删掉末尾项，也就是删除最不常用的数据项
                // map和双向链表同时变化
                removeNode(last);
                map.remove(last.key);
            } else {
                size++;
            }
            node = new Node(key,value);
            addToHead(node);
            map.put(key, node);
        } else {
            // 修改值并移动到头部
            node.val = value;
            moveToHead(node);
        }
    }

}
```



### LinkedHashMap

[精彩题解](https://leetcode-cn.com/problems/lru-cache/solution/yuan-yu-linkedhashmapyuan-ma-by-jeromememory/)

直接使用`LinkedHashMap`
```cpp
class LRUCache extends LinkedHashMap<Integer, Integer> {

    int capacity;

    public LRUCache(int capacity) {
        super(capacity, 0.75F, true); // 前两个参数无所谓，关键是第三个 true, 按照访问顺序来调整顺序
        this.capacity = capacity;
    }

    public int get(int key) {
        return getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        super.put(key, value);
    }

	// 将双向链表中最“老”的节点删除
    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        // HashMap 会在 put 方法后调用这个方法，所以下面是 >  (注意是之后)
        return size() > capacity;
    }
}
```


### LFU（最不经常使用）缓存结构设计

unfinished

```java
import java.util.*;


public class Solution {
    /**
     * lfu design
     * @param operators int整型二维数组 ops
     * @param k int整型 the k
     * @return int整型一维数组
     */

    static int counter = 0; // 时间戳计数器

    static class Node implements Comparable<Node> {
        // 这里的 key 是需要的，是因为从 TreeSet 中再去删除某个节点的时候，需要以key为键再到 HashMap 删去Node
        // 以此方式实现双向同步维护
        int key; 
        int val;
        int fre;
        int t;

        public Node(int key, int val) {
            this.key = key;
            this.val = val;
            this.fre = 1;
            this.t = ++counter;
        }

        public boolean equals(Object o) {
            if(o instanceof Node) {
                Node node = (Node)o;
                return t == node.t;
            }
            return false;
        }

        public int compareTo(Node node) {
            return fre != node.fre ? fre - node.fre : t - node.t;
        }
    }
   
    // 仿照LRU的 map+双向链表的同步维护
    Map<Integer,Node> mp = new HashMap<>();
    TreeSet<Node> set = new TreeSet<>();
    
    public int[] LFU (int[][] operators, int k) {
        // write code here
        List<Integer> list = new ArrayList<>();

        for(int[] ope : operators) {
            if(ope[0] == 1) {
                int key = ope[1];
                int val = ope[2];
                Node node = mp.get(key);
                if(node == null) {
                    if(mp.size() >= k) {
                        mp.remove(set.pollFirst().key);
                    }
                    Node newNode = new Node(key, val);
                    mp.put(key, newNode);
                    set.add(newNode);
                } else {
                    set.remove(node);
                    node.val = val;
                    ++node.fre;
                    node.t = ++counter;
                    set.add(node);
                }
            } else if(ope[0] == 2){
                Node node = mp.get(ope[1]);
                if(node == null) {
                    list.add(-1);
                } else {
                    list.add(node.val);
                    // 注意：不要误以为像redis的zset一样，调整score就可以自动调整
                    // 所以需要手动先删后加
                    set.remove(node);
                    ++node.fre;
                    node.t = ++counter;
                    set.add(node);
                }
            }
        }

        return list.stream().mapToInt(Integer::valueOf).toArray();
    }
}
```

[LFU题解参考](https://leetcode-cn.com/problems/lfu-cache/solution/java-13ms-shuang-100-shuang-xiang-lian-biao-duo-ji/#ologn-%E8%A7%A3%E6%B3%95-%E2%80%94%E2%80%94-%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%A0%B9%E5%A0%86%E6%89%BE%E5%88%B0-freq-%E6%9C%80%E5%B0%8F%EF%BC%8C%E5%9B%A0%E4%B8%BA-java-%E4%B8%AD%E7%9A%84-priorityqueue-%E9%BB%98%E8%AE%A4%E5%B0%B1%E6%98%AF%E5%B0%8F%E6%A0%B9%E5%A0%86,-%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95)

[`有时候list<Integer>和数组int[]转换很麻烦。`](https://www.cnblogs.com/cat520/p/10299879.html)






## 滑动窗口

### 雪花串

```java
import java.util.*;

public class Solution {
    /**
     * 
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int maxLength (int[] arr) {
        // write code here
        HashSet<Integer> set = new HashSet<>();
        int l = 0, r = 0 , n = arr.length;
        int ans = 0;
        for(; r < n; r++) {
            while(set.contains(arr[r])) { // l < r
                set.remove(arr[l++]);
            }
            set.add(arr[r]);
            ans = Math.max(ans, r - l + 1);
        }
        return ans;
    }
}
```



## DP

### 最长公共子串

```java
import java.util.*;

public class Solution {
    /**
     * longest common substring
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @return string字符串
     */
    int N = 5010;
    public String LCS (String str1, String str2) {
        // write code here
        int[][] f = new int[N][N]; // 
        String ans = null;
        char[] s1 = str1.toCharArray();
        char[] s2 = str2.toCharArray();
        int maxLen = 0;
        int l1 = 0, l2 = 0, n1 = s1.length, n2 = s2.length;
        for(int i = 1; i <= n1; i++) {
            for(int j = 1; j <= n2; j++) {
                if(s1[i - 1] == s2[j - 1]) {
                    f[i][j] = f[i-1][j-1] + 1;
                    if(f[i][j] > maxLen) {
                        maxLen = f[i][j];
                        l1 = i - maxLen; 
                    }
                } else {
                    f[i][j] = 0; // 子串其实更简单
                }
                /*
                if(text1[i] == text2[j]) {
                    a[i][j] = a[i-1][j-1] + 1;
                } else {
                    a[i][j] = max(a[i-1][j], a[i][j-1]);
                }
                */
            }
        }
        ans = str1.substring(l1, l1 + maxLen);
        return ans;
    }
}
```


### LCS（最长公共子序列）
key：**如何反推结果**

```java
import java.util.*;


public class Solution {
    /**
     * longest common subsequence
     *
     * @param s1 string字符串 the string
     * @param s2 string字符串 the string
     * @return string字符串
     */
    public String LCS(String s1, String s2) {
        // write code here
        int str1Len = s1.length();
        int str2Len = s2.length();
        int[][] cLenNUm = new int[s1.length() + 1][s2.length() + 1];//默认赋值，[0][?],[?][0]默认两侧皆0,类似公式中0的场景
        //构造一个LCS长度数组
        for (int i = 1; i <= str1Len; i++) {
            for (int j = 1; j <= str2Len; j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {//对应公式第二条相等
                    cLenNUm[i][j] = cLenNUm[i - 1][j - 1] + 1;
                } else {//对应公式第三条不相等
                    cLenNUm[i][j] = Math.max(cLenNUm[i][j - 1], cLenNUm[i - 1][j]);
                }
            }
        }

        //反推结果
        int i = str1Len;
        int j = str2Len;
        StringBuilder sb = new StringBuilder();//作为结果
        while (i > 0 && j > 0) {
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {//反推公式相等的场景
                //该值一定是被选取到的，根据之前的公式，知道两条字符串的下标都前进一位
                sb.append(s1.charAt(i - 1));
                i--;
                j--;
            } else { // 上面的max中，哪个大，说明从哪个转移而来，现在就倒推回去
                if (cLenNUm[i][j - 1] >= cLenNUm[i - 1][j]) {
                    j--;
                } else {
                    i--;
                }
            }
        }
        //由于是从后往前加入字符的，需要反转才能得到正确结果
        if (sb.length() == 0) return "-1";
        return sb.reverse().toString();
    }
}
```



### 编辑距离（LCS变种）

```java
import java.util.*;

public class Solution {
    /**
     * min edit cost
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @param ic int整型 insert cost
     * @param dc int整型 delete cost
     * @param rc int整型 replace cost
     * @return int整型
     */
    // 从 str1 转换到 str2的开销
    public int minEditCost (String str1, String str2, int ic, int dc, int rc) {
        // write code here
        int m = str1.length();
        int n = str2.length();
        int[][] f = new int[m + 10][n + 10];
        str1 = " " + str1; 
        str2 = " " + str2;
        f[0][0] = 0;
        for(int i = 1; i <= m; i++) {
            f[i][0] = i * dc;
        }
        for(int j = 1; j <= n; j++) {
            f[0][j] = j * ic;
        }
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                int cost = (int)1e8;
                cost = Math.min(cost, f[i - 1][j] + dc); // 不要搞反
                cost = Math.min(cost, f[i][j - 1] + ic);
                cost = Math.min(cost, f[i - 1][j - 1] + rc * (str1.charAt(i) == str2.charAt(j) ? 0 : 1));
                f[i][j] = cost;
            }
        }
        return f[m][n];
    }
}
```



## 二叉树

### 二叉树的LCA（least-common-ancestor）
```java
import java.util.*;

public class Solution {

    public int lowestCommonAncestor (TreeNode root, int o1, int o2) {
        // write code here
        if(root == null) return -1;
        if(root.val == o1) return o1;
        if(root.val == o2) return o2;
        int l1 = lowestCommonAncestor(root.left, o1, o2);
        int l2 = lowestCommonAncestor(root.right, o1, o2);
        // l1、l2 不可能同时为 -1
        if(l1 == -1) return l2;
        if(l2 == -1) return l1;
        return root.val;
    }
}
```



### 二叉树的重建 + 层序遍历
```java
import java.util.*;

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 求二叉树的右视图
     * @param xianxu int整型一维数组 先序遍历
     * @param zhongxu int整型一维数组 中序遍历
     * @return int整型一维数组
     */
    static class Node {
        int val;
        Node left, right;
        Node(int val) {
            this.val = val;
        }
    }
    
    Node root;
    int[] pre, medi;
    
    Node build(int l1, int r1 ,int l2, int r2) {
        if(l1 > r1) return null;
        int rootVal = pre[l1];
        Node node = new Node(rootVal);
        int idx = -1;
        for(int i = l2; i <= r2; i++) {
            if(medi[i] == rootVal) {
                idx = i;
                break;
            }
        }
        int leftCnt = idx - l2;

        Node leftChild = build(l1 + 1, l1 + leftCnt, l2, idx - 1);
        Node rightChild = build(l1 + leftCnt + 1, r1, idx + 1, r2);
        node.left = leftChild;
        node.right = rightChild;
        return node;
    }
    
    public int[] solve (int[] pre, int[] medi) {
        // write code here
        this.pre = pre;
        this.medi = medi;
        int n = pre.length;
        
        this.root = build(0, n - 1, 0, n - 1);
        
        List<Integer> res = new ArrayList<>();
        Queue<Node> q = new LinkedList<Node>();
        q.offer(root);
        while(q.size() > 0) {
            int cnt = q.size();
            for(int i = 0; i < cnt; i++) {
                Node node = q.poll();
                if(i == 0) {
                    res.add(node.val);
                }
                if(node.right != null) q.offer(node.right);
                if(node.left != null) q.offer(node.left);
            }
        }
        return res.stream().mapToInt(Integer::valueOf).toArray();
    }
}
```



### 二叉搜索树、完全树的判定

```java
import java.util.*;
public class Solution {
    /**
     * 
     * @param root TreeNode类 the root
     * @return bool布尔型一维数组
     */
    public boolean[] judgeIt (TreeNode root) {
        // write code here
        boolean[] res = new boolean[2];

        res[0] = isSerachTreeBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
        res[1] = isAllTreeBST(root);

        return res;

    }
     //判断搜索树(this is very important!)
    public boolean isSerachTreeBST(TreeNode root, long left, long right){
        if(root == null)return true;

        if(root.val <= left || root.val >= right) return false;

        return isSerachTreeBST(root.left, left, root.val) && isSerachTreeBST(root.right, root.val, right);
    }
    
    
    //判断完全二叉树
    // unfinished
    public boolean isAllTreeBST(TreeNode root){
        if(root == null) return true;
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        TreeNode left = null;
        TreeNode right = null;
        boolean flag = false; //标记是否遇到节点不双全的节点
        while(!queue.isEmpty()){
            root = queue.poll();
            left = root.left;
            right = root.right;
            // 遇到左右孩子不双全的节点并且该节点不是叶子节点的时候就不是完全二叉树 or  //左孩子为空并且右孩子不为空的时候不是完全二叉树
            if((flag && !(left == null && right == null)) || (left == null && right != null)         ){
                return false;
            }
            if(left != null) queue.offer(left);
            if(right != null) queue.offer(right);
            if(left == null || right == null)   flag = true;
        } 
        return true;
    }
}
```



## 双指针

### 两数之和
```java
import java.util.*;


public class Solution {
    /**
     * @param numbers int整型一维数组
     * @param target  int整型
     * @return int整型一维数组
     */
    public int[] twoSum(int[] numbers, int target) {
        // write code here
        int n = numbers.length;
        int[][] a = new int[n][2];
        for (int i = 0; i < numbers.length; i++) {
            a[i] = new int[]{numbers[i], i};
        }
        Arrays.sort(a, Comparator.comparingInt(o -> o[0]));
        int i = 0, j = n - 1;
        int[] ans = {0, 0};
        while (i < j) {
            int sum = a[i][0] + a[j][0];
            if (sum == target) {
                ans[0] = a[i][1] + 1;
                ans[1] = a[j][1] + 1;
                if (ans[0] > ans[1]) {
                    int t = ans[0];
                    ans[0] = ans[1];
                    ans[1] = t;
                }
                break;
            } else if (sum < target) {
                i++;
            } else {
                j--;
            }
        }
        return ans;
    }
}
```




### 三数之和
```java
import java.util.*;

public class Solution {
    public ArrayList<ArrayList<Integer>> threeSum(int[] num) {
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        Arrays.sort(num);
        int n = num.length;
        for(int i = 0; i < n - 2; i++) {
            if(i > 0 && num[i] == num[i-1]) continue; // 去重
            int j = i + 1;
            int k = n - 1;
            int target = -num[i];
            while(j < k) {
                if(j > i+1 && num[j] == num[j-1]) { // 去重复
                    j++;
                    continue;
                }
                if(k < n-1 && num[k] == num[k+1]) { // 去重
                    k--;
                    continue;
                }
                int sum = num[j] + num[k];
                // 两数之和的逻辑
                if(sum == target) {
                    ans.add(new ArrayList<>(Arrays.asList(num[i], num[j], num[k])));
                    // 可能还有
                    j++;
                    k--;
                } else if(sum < target) {
                    j++;
                } else {
                    k--;
                }
            }
        }
        return ans;
    }
}
```



### 接雨水

https://song-yang-ji.blog.csdn.net/article/details/114880206

```java
import java.util.*;

public class Solution {
    /**
     * max water
     * @param arr int整型一维数组 the array
     * @return long长整型
     */
    public long maxWater (int[] arr) {
        // write code here
        long ans = 0;
        int n = arr.length;
        if(n <= 2) return ans;
        int l = 1, r = n - 2;
        int lm = arr[0], rm = arr[n-1];  // 维护左端和右端的已经出现过的最大值
        while(l <= r) { // 注意是 <= 
            if(lm <= rm) {
                ans += Math.max(0, lm - arr[l]);
                lm = Math.max(lm, arr[l++]);
            } else {
                ans += Math.max(0, rm - arr[r]);
                rm = Math.max(rm , arr[r--]);
            }
        }
        return ans;
    }
}
```



## 栈、队列

### 双栈队列
```java
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>(); // 正常的栈
    Stack<Integer> stack2 = new Stack<Integer>(); // FIFO的顺序
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
        if(stack2.size() > 0) return stack2.pop();
        // 空的话，就一口气全将 “正常的栈” 弹出来
        while(!stack1.isEmpty()) {
            stack2.push(stack1.pop());
        }
        return stack2.pop();
    }
}
```



### 包含min函数的栈（单调栈）

```java
import java.util.Stack;

public class Solution {

    Stack<Integer> st = new Stack<>(), minSt = new Stack<>(); // 单调递减
    public void push(int node) {
       st.push(node);
       if(minSt.isEmpty() || node <= minSt.peek()) { // notice <= 
           minSt.push(node);
       }
     }
    
    public void pop() {
        int x = st.pop();
        if(x == minSt.peek()) {
            minSt.pop();
        }
    }
    
    public int top() {
        return st.peek();
    }
    
    public int min() {
        return minSt.peek();
    }
}
```


### 表达式计算问题
unfinished
```java
import java.util.*;

public class Solution {
    // 使用 map 维护一个运算符优先级
    // 这里的优先级划分按照「数学」进行划分即可
    Map<Character, Integer> map = new HashMap<Character, Integer>() {{
        put('-', 1);
        put('+', 1);
        put('*', 2);
        put('/', 2);
        put('%', 2);
        put('^', 3);
    }};

    public int solve(String s) {
        // 将所有的空格去掉
        s = s.replaceAll(" ", "");

        char[] cs = s.toCharArray();
        int n = s.length();

        // 存放所有的数字
        Deque<Integer> nums = new ArrayDeque<>();
        // 为了防止第一个数为负数，先往 nums 加个 0
        nums.addLast(0);
        // 存放所有「非数字以外」的操作
        Deque<Character> ops = new ArrayDeque<>();

        for (int i = 0; i < n; i++) {
            char c = cs[i];
            if (c == '(') {
                ops.addLast(c);
            } else if (c == ')') {
                // 计算到最近一个左括号为止
                while (!ops.isEmpty()) {
                    if (ops.peekLast() != '(') {
                        calc(nums, ops);
                    } else {
                        ops.pollLast();
                        break;
                    }
                }
            } else {
                if (isNumber(c)) {
                    int u = 0;
                    int j = i;
                    // 将从 i 位置开始后面的连续数字整体取出，加入 nums
                    while (j < n && isNumber(cs[j])) u = u * 10 + (cs[j++] - '0');
                    nums.addLast(u);
                    i = j - 1;
                } else {
                    if (i > 0 && (cs[i - 1] == '(' || cs[i - 1] == '+' || cs[i - 1] == '-')) {
                        nums.addLast(0);
                    }
                    // 有一个新操作要入栈时，先把栈内可以算的都算了 
                    // 只有满足「栈内运算符」比「当前运算符」优先级高/同等，才进行运算
                    while (!ops.isEmpty() && ops.peekLast() != '(') {
                        char prev = ops.peekLast();
                        if (map.get(prev) >= map.get(c)) {
                            calc(nums, ops);
                        } else {
                            break;
                        }
                    }
                    ops.addLast(c);
                }
            }
        }
        // 将剩余的计算完
        while (!ops.isEmpty() && ops.peekLast() != '(') calc(nums, ops);
        return nums.peekLast();
    }

    // 计算逻辑：从 nums 中取出两个操作数，从 ops 中取出运算符，然后根据运算符进行计算即可
    void calc(Deque<Integer> nums, Deque<Character> ops) {
        if (nums.isEmpty() || nums.size() < 2) return;
        if (ops.isEmpty()) return;
        int b = nums.pollLast(), a = nums.pollLast();
        char op = ops.pollLast();
        int ans = 0;
        if (op == '+') ans = a + b;
        else if (op == '-') ans = a - b;
        else if (op == '*') ans = a * b;
        else if (op == '/') ans = a / b;
        else if (op == '^') ans = (int) Math.pow(a, b);
        else if (op == '%') ans = a % b;
        nums.addLast(ans);
    }

    boolean isNumber(char c) {
        return Character.isDigit(c);
    }
}
```




**单调栈**的思想
```java
import java.util.*;

/**
 * 本解法并未解决单元运算符 + - 的问题。
 * 细节
 * 1. 空格事先过滤
 * 2. 遇到整数一次性处理出来
 * 3. 注意先出栈的是第二个运算数，然后才是第一个运算数
 * 4. 遇到 '(' 直接入操作符栈； 遇到')' ，要一直算到 '('
 * 尤其是第4点；
 * 本题的核心思想，运算符栈实际上是一个单调栈，栈内的运算符优先级严格递增，
 * 也就是说，[+,*]:[2,3,4]是合法的，它表示 2 + 3 * 4；
 * [*,+]:[2,3,4]是不可以的，它实际上是2*3+4，但却被处理成 2*(3+4)
 * 
 */
public class Solution {

    static class Opt {
        char c;
        int priority;

        public Opt(char c) {
            this.c = c;
            int p = -1; // '(' 为 -1
            switch (c) {
                case '+':
                case '-':
                    p = 1;
                    break;
                case '*':
                    p = 2;
                    break;
            }
            this.priority = p;
        }

        public boolean isHigh(Opt o) {
            return this.priority > o.priority;
        }
    }

    void handle(Opt opt) {
        // 注意先出栈的是第二个运算数
        int x2 = nums.pop();
        int x1 = nums.pop();
        switch (opt.c) {
            case '*':
                nums.push(x1 * x2);
                break;
            case '+':
                nums.push(x1 + x2);
                break;
            case '-':
                nums.push(x1 - x2);
                break;
            default:
                break;
        }
    }

    Stack<Opt> ops = new Stack<>();
    Stack<Integer> nums = new Stack<>();

    public int solve(String s) {

        s = s.replaceAll(" ",""); // 预处理

        // write code here
        char[] cs = s.toCharArray();
        int n = cs.length;

        for (int i = 0; i < n;) {
            if (Character.isDigit(cs[i])) {
                StringBuilder number = new StringBuilder();
                while (i < n && Character.isDigit(cs[i])) {
                    number.append(cs[i++]);
                }
                int val = Integer.parseInt(number.toString());
                nums.push(val);
            } else {
                if (cs[i] == '(') {
                    ops.push(new Opt(cs[i]));
                } else if (cs[i] == ')') {
                    while (!ops.isEmpty()) {
                        Opt opt = ops.pop();
                        if (opt.c == '(') break;
                        handle(opt);
                    }
                } else {
                    Opt opt = new Opt(cs[i]);
                    while (!ops.isEmpty() && !opt.isHigh(ops.peek())) { // 运算符保持递增
                        handle(ops.pop());
                    }
                    ops.push(opt);
                }
                i++;
            }
        }
        while (!ops.isEmpty()) {
            handle(ops.pop());
        }
        return nums.pop();
    }
    
}
```



## 二分

### 两个有序数组找中位数

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        if (totalLength % 2 == 1) {
            int midIndex = totalLength / 2;
            double median = getKthElement(nums1, nums2, midIndex + 1);
            return median;
        } else {
            int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
            double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
            return median;
        }
    }

    public int getKthElement(int[] nums1, int[] nums2, int k) {
        /* 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
         * 这里的 "/" 表示整除
         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个
         * 这样 pivot 本身最大也只能是第 k-1 小的元素
         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
         * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
         */

        int length1 = nums1.length, length2 = nums2.length;
        int index1 = 0, index2 = 0;
        int kthElement = 0;

        while (true) {
            // 边界情况
            if (index1 == length1) {
                return nums2[index2 + k - 1];
            }
            if (index2 == length2) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return Math.min(nums1[index1], nums2[index2]);
            }
            
            // 正常情况
            int half = k / 2;
            int newIndex1 = Math.min(index1 + half, length1) - 1; // notice - 1
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }
        }
    }
}
```

### 搜索旋转排序数组
>整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。


[搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

~~大的方面的思路：先找出分段点，然后在两段分别增序的数字中进行二分查找。~~

```cpp
class Solution {
public:
    int search(vector<int>& a, int target) {
        int n = a.size(), l = 0 ,r = a.size()-1;
        if(n==0) return -1; //特判
        while(l<r){
            int mid = (l+r)/2;
            if(a[mid]<a[0]) r = mid;                
            else l = mid + 1;
        }
        if(a[l]>=a[0]) return binary_search(a,0,n-1,target);
        if(target<a[0] && target>a[n-1] ) return -1;
        if(target>=a[0]) return binary_search(a,0,l-1,target);
        if(target<=a[n-1]) return binary_search(a,l,n-1,target);
        return -1;
    }
    int binary_search(const vector<int>& nums,int l,int r,int target){
        while(l<=r){
            int mid = (l+r)/2;
            if(nums[mid] == target) return mid;
            else if(nums[mid]<target) l = mid+1;
            else r = mid-1;
        }
        return -1;
    }
};
```

更优雅的方法

unfinished



**要么排除掉一部分，要么在一个标准的单调区间里去查询**

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = (int)nums.size();
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            // [0 ~ mid] 是有序的
            if (nums[0] <= nums[mid]) {
                // 然后就在有序区间里操作了
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                // 或者排除这个有序区间
                } else {
                    l = mid + 1;
                }
            // [mid ~ n-1] 是有序的    
            } else {
                // 然后就在有序区间里操作了
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                // 或者排除这个有序区间    
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};
```

### LIS（最长上升子序列）二分+贪心
unfinished
**如何还原最长上升子序列?** 

二分+贪心去求的同时维护每个位置的最大长度；
再倒序还原。
```java
import java.util.*;

public class Solution {
    /**
     * retrun the longest increasing subsequence
     * @param arr int整型一维数组 the array
     * @return int整型一维数组
     */
    int lowerBound(List<Integer> list, int key) {
        if(key > list.get(list.size() - 1)) return list.size();
        int l = 0, r = list.size() - 1;
        while(l < r) {
            int mid = l + (r - l)/2;
            if(list.get(mid) >= key) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
    
    public int[] LIS (int[] arr) {
        // write code here
        int n = arr.length;
        List<Integer> list = new ArrayList<>();
        int[] maxLen = new int[n];  // 以对应下标结尾的串的最长LIS的长度
        
        int idx = 0;
        for(int x: arr) {
            if(list.isEmpty() || x > list.get(list.size() - 1)) {
                list.add(x);
                maxLen[idx] = list.size();
            } else {
                int pos = lowerBound(list,x);
                list.set(pos, x);
                maxLen[idx] = pos + 1;
            }
            ++idx;
        }
        // maxLen[i1] maxLen[i2] 相同的情况下，要后面的，否则就找到了一条更长的序列
        int id = list.size();
        for(int i = n - 1; i >= 0; --i) {
            if(maxLen[i] == id) {
                list.set(--id,arr[i]);
            }
        }
        return list.stream().mapToInt(Integer::valueOf).toArray();
    }
}
```



## 递归（dfs）


### 字符串的全排列

```java
import java.util.*;

public class Solution {
    Set<String> res = new HashSet<>();
    char[] cs;
    boolean[] st;
    int n;
    String str;
    
    public ArrayList<String> Permutation(String str) {
        n = str.length();
        cs = new char[n];
        st = new boolean[n];
        this.str = str;
        dfs(0);
        return new ArrayList<>(res);
    }
    
    void dfs(int pos) {
        if(pos == n) {
            res.add(new String(cs));
            return;
        }
        for(int i = 0; i < n; i++) {
            if(!st[i]) {
                st[i] = true;
                cs[pos] = str.charAt(i);
                dfs(pos+1);
                st[i] = false;
            }
        }
    }
    
}
```

直接去重

```java
import java.util.*;

public class Solution {
    
    int n;
    String str;
    StringBuilder sb = new StringBuilder();
    boolean[] used = new boolean[15];
    
    ArrayList<String> ans = new ArrayList<>();
    
    public ArrayList<String> Permutation(String str) {
        n = str.length();
        char[] cs = str.toCharArray();
        Arrays.sort(cs);
        this.str = new String(cs);
        dfs(0);
        return ans;
    }
    
    void dfs(int pos) {
        if(pos == n) {
            ans.add(sb.toString());
            return;
        }
        int old = -1;
        for(int i = 0; i < n; i++) {
            if(!used[i]) {
                if(old >= 0 && str.charAt(i) == str.charAt(old) ) {  // key code
                    continue;
                }
                used[i] = true;
                old = i;
                sb.append(str.charAt(i));
                dfs(pos + 1);
                used[i] = false;
                sb.deleteCharAt(sb.length() - 1);
            }
        }
    }
}
```



## 其他

### 连续子数组的最大和（前缀和）
```java
import java.util.*;

// 前缀和
public class Solution {
    int N = 100000000;
    public int FindGreatestSumOfSubArray(int[] array) {
        int ans = -N;
        int sum = 0;
        int preMin = 0;
        for(int x : array) {
            sum += x;
            ans = Math.max(ans, sum - preMin);
            preMin = Math.min(preMin, sum);
        }
        return ans;
    }
}
```

### 超过半数的数
**候选法（最优解）**
```java
public class Solution {
    public int MoreThanHalfNum_Solution(int [] a) {
        int candi = -1;
        int vote = 0;
        for(int x : a) {
            if(vote == 0) {
                candi = x;
                ++vote;
            } else {
                if(x == candi) {
                    ++vote;
                } else {
                    --vote;
                }
            }
        }
        return candi;
    }
}
```

### 有序矩阵的搜索
```java
import java.util.*;

public class Solution {
    public int[] findElement(int[][] mat, int m, int n, int x) {
        // write code here
        int resi = -1, resj = -1;
        int i = 0, j = n - 1;
        while(i < m && j >= 0) {
            if(mat[i][j] == x) return new int[]{i, j};
            else if(mat[i][j] > x){
                while(j >= 0 && mat[i][j] > x) {
                    --j;
                }
            }
            ++i;
        }
        return new int[]{resi, resj};
    }
}
```


```java
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        if(m == 0) return false;
        int n = matrix[0].size();
        // 从右上角进行搜索
        int j = n - 1 , i = 0;
        while(j >= 0 && i < m) {
            // 移动到第一个小于等于 target的地方
            while(j >= 0 && matrix[i][j] > target) j--;
            // 检查
            if(j >= 0 && matrix[i][j] == target) return true;
            // 此时 matrix[i][j]是小于 target的
            i++;
        }
        return false;
    }
};
```

### 进制转换

```java
import java.util.*;

public class Solution {
    /**
     * 进制转换
     * @param M int整型 给定整数
     * @param N int整型 转换到的进制
     * @return string字符串
     */
    public String solve (int M, int N) {
        // write code here
        boolean nega = false;
        if(M < 0) {
            nega = true;
            M = -M;
        }
        char[] mp = new char[20];
        for(int i = 0; i < 10; i++) mp[i] = (char) (i + '0');
        for(int i = 10; i <= 16; i++)  mp[i] = (char) ((i-10) + 'A');
        LinkedList<Character> res = new LinkedList<>();
        
        while (M > 0) {
            res.addFirst(mp[M%N]);
            M /= N;
        }
        
        if(nega) res.addFirst('-');
        StringBuilder stringBuilder = new StringBuilder();
        for (Character c : res) {
            stringBuilder.append(c);
        }
        return stringBuilder.toString();
    }
}
```





### 区间合并

```java
import java.util.*;

public class Solution {
    public ArrayList<Interval> merge(ArrayList<Interval> intervals) {
        intervals.sort((i1,i2) -> {
            return i1.start - i2.start;
        });
        ArrayList<Interval> ans = new ArrayList<>();
        int n = intervals.size();
        if(n < 1) return intervals;
        
        Interval x = intervals.get(0);
        int i = 1;
        while(i < n) {
            Interval y = intervals.get(i);
            if(y.start > x.end) {
                ans.add(x);
                x = y;
            } else {
                x.end = Math.max(x.end, y.end);
            }
            ++i;
        }
        ans.add(x);
        return ans;
    }
}
```

```java
import java.util.*;

public class Solution {
    public ArrayList<Interval> merge(ArrayList<Interval> intervals) {
        int N = 2*10010;
        int[] dif = new int[N];
        boolean[] isTail = new boolean[N];
        boolean[] isHead = new boolean[N];
        for(Interval it : intervals) {
            ++dif[2*it.start];
            --dif[2*it.end + 1];
        }
        for(int i = 1; i < N; i++) {
            dif[i] += dif[i - 1];
        }
        ArrayList<Interval> res = new ArrayList<>();
        
        int i = 0;
        while(i < N) {
            int x,y;
            while(i < N && dif[i] == 0) ++i;
            if(i == N) break;
            x = i;
            while(i < N && dif[i] > 0) ++i;
            y = i - 1;
            res.add(new Interval(x/2, y/2));
        }
        return res;
    }
    
}
```



最长回文串

1. 中心拓展法
2. dp
3. 字符串哈希
4. 马拉车

https://song-yang-ji.blog.csdn.net/article/details/114220574