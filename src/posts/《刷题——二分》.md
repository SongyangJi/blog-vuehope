---
title: 《刷题——二分》
date: 2023-01-09 04:27:52
categories: 算法题
tags:
---



## 二分

### 两个有序数组找中位数
```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        if (totalLength % 2 == 1) {
            int midIndex = totalLength / 2;
            double median = getKthElement(nums1, nums2, midIndex + 1);
            return median;
        } else {
            int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
            double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
            return median;
        }
    }

    public int getKthElement(int[] nums1, int[] nums2, int k) {
        /* 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
         * 这里的 "/" 表示整除
         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个
         * 这样 pivot 本身最大也只能是第 k-1 小的元素
         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
         * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
         */

        int length1 = nums1.length, length2 = nums2.length;
        int index1 = 0, index2 = 0;
        int kthElement = 0;

        while (true) {
            // 边界情况
            if (index1 == length1) {
                return nums2[index2 + k - 1];
            }
            if (index2 == length2) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return Math.min(nums1[index1], nums2[index2]);
            }
            
            // 正常情况
            int half = k / 2;
            int newIndex1 = Math.min(index1 + half, length1) - 1; // notice - 1
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }
        }
    }
}
```



### 搜索旋转排序数组

>整数数组 nums 按升序排列，数组中的值 互不相同 。
>在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。


[搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

~~大的方面的思路：先找出分段点，然后在两段分别增序的数字中进行二分查找。~~

```cpp
class Solution {
public:
    int search(vector<int>& a, int target) {
        int n = a.size(), l = 0 ,r = a.size()-1;
        if(n==0) return -1; //特判
        while(l<r){
            int mid = (l+r)/2;
            if(a[mid]<a[0]) r = mid;                
            else l = mid + 1;
        }
        if(a[l]>=a[0]) return binary_search(a,0,n-1,target);
        if(target<a[0] && target>a[n-1] ) return -1;
        if(target>=a[0]) return binary_search(a,0,l-1,target);
        if(target<=a[n-1]) return binary_search(a,l,n-1,target);
        return -1;
    }
    int binary_search(const vector<int>& nums,int l,int r,int target){
        while(l<=r){
            int mid = (l+r)/2;
            if(nums[mid] == target) return mid;
            else if(nums[mid]<target) l = mid+1;
            else r = mid-1;
        }
        return -1;
    }
};
```



更优雅的方法

**要么排除掉一部分，要么在一个标准的单调区间里去查询**

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = (int)nums.size();
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            // [0 ~ mid] 是有序的
            if (nums[0] <= nums[mid]) {
                // 然后就在有序区间里操作了
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                // 或者排除这个有序区间
                } else {
                    l = mid + 1;
                }
            // [mid ~ n-1] 是有序的    
            } else {
                // 然后就在有序区间里操作了
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                // 或者排除这个有序区间    
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};
```



### LIS（最长上升子序列）二分+贪心

key：**如何还原最长上升子序列?** 

二分+贪心去求的同时维护每个位置的最大长度；
再倒序还原。
```java
import java.util.*;

public class Solution {
    /**
     * retrun the longest increasing subsequence
     * @param arr int整型一维数组 the array
     * @return int整型一维数组
     */
    int lowerBound(List<Integer> list, int key) {
        if(key > list.get(list.size() - 1)) return list.size();
        int l = 0, r = list.size() - 1;
        while(l < r) {
            int mid = l + (r - l)/2;
            if(list.get(mid) >= key) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
    
    public int[] LIS (int[] arr) {
        // write code here
        int n = arr.length;
        List<Integer> list = new ArrayList<>();
        int[] maxLen = new int[n];  // 以对应下标结尾的串的最长LIS的长度
        
        int idx = 0;
        for(int x: arr) {
            if(list.isEmpty() || x > list.get(list.size() - 1)) {
                list.add(x);
                maxLen[idx] = list.size();
            } else {
                int pos = lowerBound(list,x);
                list.set(pos, x);
                maxLen[idx] = pos + 1;
            }
            ++idx;
        }
        // maxLen[i1] maxLen[i2] 相同的情况下，要后面的，否则就找到了一条更长的序列
        int id = list.size();
        for(int i = n - 1; i >= 0; --i) {
            if(maxLen[i] == id) {
                list.set(--id, arr[i]);
            }
        }
        return list.stream().mapToInt(Integer::valueOf).toArray();
    }
}
```





### 寻找数组的峰值

给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。
1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于
2.假设 nums[-1] = nums[n] = -\infty−∞
3.对于所有有效的 i 都有 nums[i]  != nums[i + 1]

```java
import java.util.*;

public class Solution {
   
    public int findPeakElement (int[] nums) {
        int n = nums.length;
        int l = 0, r = n - 1;
        while(l < r) {
            int mid = l + (r - l)/2;
            if(nums[mid] < nums[mid + 1]) { // key
                l = mid  + 1;
            } else {
                r = mid;
            }
        }
        // write code here
        return l;
    }
}
```

